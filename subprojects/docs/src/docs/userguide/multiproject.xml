<!--
  ~ Copyright 2009 the original author or authors.
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->
<chapter id='multi_project_builds' xml:lang="ja">
    <title>マルチプロジェクトのビルド<phrase role="original">Multi-project Builds</phrase></title>
    <para role="original">The powerful support for multi-project builds is one of Gradle's unique selling points. This topic is also the
        most intellectually challenging.
    </para>
    <para>マルチプロジェクトはビルドツールの知恵の絞りどころであり、とてもやりがいのあるテーマです。Gradleはマルチプロジェクトを強力にサポートしていて、ユニークなセールスポイントの一つとなっています。</para>
    <section id='sec:cross_project_configuration'>
        <title>クロスプロジェクト設定<phrase role="original">Cross project configuration</phrase></title>
        <para role="original">Let's start with a very simple multi-project build. After all Gradle is a general purpose build tool at
            its core, so the projects don't have to be java projects. Our first examples are about marine life.
        </para>
        まず、ごく簡単な例から始めましょう。なんと言ってもGradleは汎用のビルドツールですので、扱うプロジェクトがJavaプロジェクトである必要はありません。これから例として使用するプロジェクトは、海洋生物に関するものです。
        <section>
            <title>Configuration and execution</title>
            <para><xref linkend="sec:build_phases"/> describes the phases of every Gradle build.
                Let's zoom into configuration and execution phases of a multi-project build.
                The configuration of all projects happens before any task is executed.
                This means that when a single task, from a single project is requested,
                <emphasis>all</emphasis> projects of multi-project build are configured first.
                The reason every project needs to be configured is to support
                the flexibility of accessing and changing any part of Gradle project model.
            </para>
            <section id='sec:configuration_on_demand'>
                <title>Configuration on demand</title>
                <para>Configuration injection feature and access to the complete project model
                    are possible because every project is configured before the execution phase.
                    Yet, this approach may not be the most efficient in a very large multi-project builds.
                    There are Gradle builds with a hierarchy of hundreds of subprojects.
                    Configuration time of huge multi-project builds may become noticeable.
                    Scalability is an important requirement for Gradle. Hence, starting from version 1.4
                    new incubating 'configuration on demand' mode is introduced.</para>
                <para>
                    Configuration on demand mode attempts to configure only projects that are relevant for requested tasks.
                    This way, the configuration time of a large multi-project build is greatly improved.
                    In the long term, this mode will become the default mode, possibly the only mode for Gradle build execution.
                    The configuration on demand feature is incubating so not every build is guaranteed to work correctly.
                    The feature should work very well for multi-project builds that have decoupled projects (<xref linkend="sec:decoupled_projects"/>).
                    In configuration on demand mode projects are configured as follows:
                    <itemizedlist>
                        <listitem>Root project is always configured.
                            This way the typical common configuration is supported (allprojects or subprojects script blocks).</listitem>
                        <listitem>Project in the directory where the build is executed is also configured, but only when Gradle is executed without any tasks.
                            This way the default tasks behave correctly when projects are configured on demand.</listitem>
                        <listitem>The standard project dependencies are supported and makes relevant projects configured.
                            If project A has a compile dependency on project B then building A causes configuration of both projects: A and B.</listitem>
                        <listitem>The task dependencies declared via task path are supported and cause relevant projects configured.
                            Example: someTask.dependsOn(":someOtherProject:someOtherTask")
                        </listitem>
                        <listitem>Task requested via task path from the command line (or Tooling API) causes the relevant project configured.
                            Building 'projectA:projectB:someTask' causes configuration of projectB.
                        </listitem>
                    </itemizedlist>
                </para>
                <para>
                    Eager to try out this new feature? To configure on demand with every build run see <xref linkend="sec:gradle_configuration_properties"/>.
                    To configure on demand just for given build please see <xref linkend="gradle_command_line"/>.
                </para>
            </section>
        </section>
        <section>
            <title>共通の振る舞いを定義する<phrase role="original">Defining common behavior</phrase></title>
            <para role="original">We have the following project tree. This is a multi-project build with a root project
                <literal>water</literal> and a subproject <literal>bluewhale</literal>.
            </para>
            <para>このプロジェクトは、以下のような木構造になっています。ルートプロジェクト「<literal>water</literal>」と、サブプロジェクトの「<literal>bluewhale</literal>(シロナガスクジラ)」からなるマルチプロジェクトです。</para>
            <sample id="multiprojectFirstExample" dir="userguide/multiproject/firstExample/water" includeLocation="true" title="マルチプロジェクト・ツリー - warter &amp; bluewhale プロジェクト / Multi-project tree - water &amp; bluewhale projects">
                <layout>
                    build.gradle
                    settings.gradle
                    bluewhale/
                </layout>
                <sourcefile file="settings.gradle"/>
            </sample>
            <para role="original">And where is the build script for the <literal>bluewhale</literal> project? In Gradle build scripts are optional.
                Obviously for a single project build, a project without a build script doesn't make much sense. For
                multiproject builds the situation is different. Let's look at the build script for the <literal>water</literal> project and
                execute it:
            </para>
            <para>で、<literal>bluewhale</literal>プロジェクトのビルドスクリプトは何処にあるのでしょう。Gradleでは、ビルドスクリプトは必須ではありません。シングルプロジェクトのビルドではビルドスクリプトのないプロジェクトなどたいした意味はありませんが、マルチプロジェクトの場合そうとは限りません。<literal>water</literal>のビルドスクリプトを見てみましょう。</para>
            <sample id="multiprojectFirstExample" dir="userguide/multiproject/firstExample/water" title="water(親プロジェクト)のビルドスクリプト / Build script of water (parent) project">
                <sourcefile file="build.gradle"/>
                <output args="-q hello"/>
            </sample>
            <para role="original">Gradle allows you to access any project of the multi-project build from any build script. The Project
                API provides a method called <literal>project()</literal>, which takes a path as an argument and returns
                the Project object for this path. The capability to configure a project build from any build script we
                call <firstterm>cross project configuration</firstterm>. Gradle implements this via
                <firstterm>configuration injection</firstterm>.
            </para>
            <para>Gradleでは、マルチプロジェクトを構成するすべてのプロジェクトに、どのビルドスクリプトからでもアクセスすることができます。ビルドスクリプトでは<literal>project()</literal>というメソッドを使用でき、引数にプロジェクトへのパスを渡せばProjectオブジェクトを取得できます。つまり、あるプロジェクトを設定しようとしたとき、マルチプロジェクト内どのビルドスクリプトからでもプロジェクトを取得して設定できるのです。このことを、私たちは<firstterm>クロスプロジェクト設定</firstterm>と呼んでいます。Gradleは、この機能を<firstterm>設定のインジェクション</firstterm>を利用して実現します。</para>
            <para role="original">We are not that happy with the build script of the <literal>water</literal>  project. It is inconvenient to add the task
                explicitly for every project. We can do better. Let's first add another project called
                <literal>krill</literal> to our multi-project build.
            </para>
            <para><literal>water</literal>プロジェクトのビルドスクリプトは、まだ満足できるものではありません。すべてのプロジェクトに手でこのタスクを追加していくのは面倒ですよね。もっといい書き方ができます。<literal>krill(オキアミ)</literal>プロジェクトをマルチプロジェクトに追加してみましょう。</para>
            <sample id="multiprojectAddKrill" dir="userguide/multiproject/addKrill/water" includeLocation="true" title="マルチプロジェクトツリー - water, bluewhaleそしてkrill">
                <layout>
                    build.gradle
                    settings.gradle
                    bluewhale/
                    krill/
                </layout>
                <sourcefile file="settings.gradle"/>
            </sample>
            <para role="original">Now we rewrite the <literal>water</literal> build script and boil it down to a single line.</para>
            <para><literal>water</literal>ビルドスクリプトを書き直し、一行で記述するようにします。</para>
            <sample id="multiprojectAddKrill" dir="userguide/multiproject/addKrill/water" title="Waterプロジェクトのビルドスクリプト / Water project build script">
                <sourcefile file="build.gradle"/>
                <output args="-q hello"/>
            </sample>
            <para role="original">Is this cool or is this cool? And how does this work? The Project API provides a property
                <literal>allprojects</literal>
                which returns a list with the current project and all its subprojects underneath it. If you call
                <literal>allprojects</literal>
                with a closure, the statements of the closure are delegated to the projects associated with <literal>
                    allprojects</literal>. You could also do an iteration via <literal>allprojects.each</literal>, but
                that would be more verbose.
            </para>
            <para>素晴らしい。これはどういう原理で動いているのでしょう。プロジェクトAPIは<literal>allprojects</literal>というプロパティを提供しており、そのプロパティには現在のプロジェクトと、そのサブプロジェクトのリストが格納されています。 <literal>allprojects</literal>をクロージャとともに呼び出せば、クロージャの実行が<literal>allprojects</literal>に格納されたすべてのプロジェクトに委譲されます。もちろん<literal>allprojects</literal>をeachでループすることもできますが、記述が冗長になってしまいます。</para>
            <para role="original">Other build systems use inheritance as the primary means for defining common behavior. We also offer
                inheritance for projects as you will see later. But Gradle uses configuration injection as the usual way
                of defining common behavior. We think it provides a very powerful and flexible way of configuring
                multiproject builds.
            </para>
            <para>他のビルドシステムでは、プロジェクト間の共通設定を行う方法として主に継承を使用します。後ほど紹介するように、Gradleでも同様にプロジェクト間の継承を使用することが出来ますが、Gradleではもっと使いやすい共通設定の定義方法としてこの設定のインジェクションを使用します。設定の継承に比べて、設定を注入する方が柔軟性のある強力な方法だと考えているからです。</para>
        </section>
    </section>
    <section id='sec:subproject_configuration'>
        <title>サブプロジェクトの設定<phrase role="original">Subproject configuration</phrase></title>
        <para role="original">The Project API also provides a property for accessing the subprojects only.
        </para>
        <para>プロジェクトAPIはサブプロジェクトのみにアクセスする方法も提供します。</para>
        <section>
            <title>共通の振る舞いを定義する<phrase role="original">Defining common behavior</phrase></title>
            <sample id="multiprojectUseSubprojects" dir="userguide/multiproject/useSubprojects/water" title="サブプロジェクト共通の振る舞いとすべてのプロジェクト共通の振る舞いをそれぞれ定義する / Defining common behaviour of all projects and subprojects">
                <sourcefile file="build.gradle"/>
                <output args="-q hello"/>
            </sample>
        </section>
        <section id='sub:adding_specific_behavior'>
            <title>個別の振る舞いを追加する<phrase role="original">Adding specific behavior</phrase></title>
            <para role="original">You can add specific behavior on top of the common behavior. Usually we put the project specific
                behavior in the build script of the project where we want to apply this specific behavior. But as we
                have already seen, we don't have to do it this way. We could add project specific behavior for the
                <literal>bluewhale</literal> project like this:
            </para>
            <para>共通の振る舞いの上に、それぞれのプロジェクト個別の振る舞いを追加することができます。普通は、プロジェクト個別の振る舞いはそのプロジェクトのビルドスクリプトに記述しますが、いままで見てきたようにかならずそうしなければいけないという訳ではありません。次の例に示すような方法で、サブプロジェクト<literal>bluewhale</literal>に個別の振る舞いを追加することもできます。</para>
            <sample id="multiprojectSubprojectsAddFromTop" dir="userguide/multiproject/subprojectsAddFromTop/water" title="プロジェクト個別の振る舞いを定義する / Defining specific behaviour for particular project">
                <sourcefile file="build.gradle"/>
                <output args="-q hello"/>
            </sample>
            <para role="original">As we have said, we usually prefer to put project specific behavior into the build script of this
                project. Let's refactor and also add some project specific behavior to the <literal>krill</literal>
                project.
            </para>
            <para>前述のとおり、プロジェクト個別の振る舞いは、普通そのプロジェクトのビルドスクリプトに記述します。リファクタリングし、さらに<literal>krill</literal>プロジェクトにも振る舞いを追加してみましょう。</para>
            <sample id="multiprojectSpreadSpecifics" dir="userguide/multiproject/spreadSpecifics/water" includeLocation="true" title="krillプロジェクトに個別の振る舞いを定義する / Defining specific behaviour for project krill">
                <layout>
                    build.gradle
                    settings.gradle
                    bluewhale/build.gradle
                    krill/build.gradle
                </layout>
                <sourcefile file="settings.gradle"/>
                <sourcefile file="bluewhale/build.gradle"/>
                <sourcefile file="krill/build.gradle"/>
                <sourcefile file="build.gradle"/>
                <output args="-q hello"/>
            </sample>
        </section>
        <section id='sub:project_filtering'>
            <title>プロジェクトのフィルタリング<phrase role="original">Project filtering</phrase></title>
            <para role="original">To show more of the power of configuration injection, let's add another project
                called <literal>tropicalFish</literal> and add more behavior to the build via the build script of the
                <literal>water</literal> project.
            </para>
            <para>設定のインジェクションが持つもっと大きな力をお見せするために、<literal>tropicalFish(熱帯魚)</literal>プロジェクトを追加します。このプロジェクトに、<literal>water</literal>プロジェクトのビルドスクリプトから振る舞いを定義していきます。</para>
            <section id='ssub:filtering_by_name'>
                <title>名前によるフィルタリング<phrase role="original">Filtering by name</phrase></title>
                <sample id="multiprojectAddTropical" dir="userguide/multiproject/addTropical/water" includeLocation="true" title="プロジェクトに振る舞いを追加する(プロジェクト名によるフィルタリング) / Adding custom behaviour to some projects (filtered by project name)">
                    <layout>
                        build.gradle
                        settings.gradle
                        bluewhale/build.gradle
                        krill/build.gradle
                        tropicalFish/
                    </layout>
                    <sourcefile file="settings.gradle"/>
                    <sourcefile file="build.gradle"/>
                    <output args="-q hello"/>
                </sample>
                <para role="original">The <literal>configure()</literal> method takes a list as an argument and applies the
                    configuration to the projects in this list.
                </para>
                <para>configure()は引数にリストを取るメソッドで、そのリストに格納されたプロジェクトに設定を適用します。</para>
            </section>
            <section id='ssub:filtering_by_properties'>
                <title>プロパティによるフィルタリング<phrase role="original">Filtering by properties</phrase></title>
                <para role="original">Using the project name for filtering is one option. Using extra project properties is another.
                    (See <xref linkend='sec:extra_properties'/> for more information on extra properties.)
                </para>
                <para>フィルタリングには、プロジェクト名だけでなく拡張プロパティを使うこともできます。(拡張プロパティの詳細については、<xref linkend='sec:extra_properties'/>を参照してください。)</para>
                <sample id="multiprojectTropicalWithProperties" dir="userguide/multiproject/tropicalWithProperties/water" includeLocation="true" title="プロジェクトに振る舞いを追加する(プロパティによるフィルタリング) / Adding custom behaviour to some projects (filtered by project properties)">
                    <layout>
                        build.gradle
                        settings.gradle
                        bluewhale/build.gradle
                        krill/build.gradle
                        tropicalFish/build.gradle
                    </layout>
                    <sourcefile file="settings.gradle"/>
                    <sourcefile file="bluewhale/build.gradle"/>
                    <sourcefile file="krill/build.gradle"/>
                    <sourcefile file="tropicalFish/build.gradle"/>
                    <sourcefile file="build.gradle"/>
                    <output args="-q hello"/>
                </sample>
                <para role="original">In the build file of the <literal>water</literal> project we use an <literal>afterEvaluate</literal>
                    notification. This means that the closure we are passing gets evaluated <emphasis>after</emphasis>
                    the build scripts of the subproject are evaluated. As the property <literal>arctic</literal>
                    is set in those build scripts, we have to do it this way. You will find more on this topic in
                    <xref linkend='sec:dependencies_which_dependencies'/>
                </para>
                <para><literal>water</literal>プロジェクトのビルドスクリプトでは、<literal>afterEvaluate</literal>という宣言文が使用されています。<literal>afterEvaluate</literal>に引き渡されたクロージャは、そのプロジェクトのビルドスクリプトが評価された<emphasis>後に</emphasis>実行されます。サブプロジェクトの<literal>arctic</literal>プロパティは、それぞれのプロジェクトのビルドスクリプト内でセットされているので、この方法で<literal>arctic</literal>プロパティにアクセスする必要があるのです。このトピックは<xref linkend='sec:dependencies_which_dependencies'/>で詳しく説明します。</para>
            </section>
        </section>
    </section>
    <section id='sec:execution_rules_for_multi_project_builds'>
        <title>マルチプロジェクトのビルド実行ルール<phrase role="original">Execution rules for multi-project builds</phrase></title>
        <para role="original">When we have executed the <literal>hello</literal> task from the root project dir things behaved in an
            intuitive way. All the <literal>hello</literal> tasks of the different projects were executed. Let's switch
            to the <literal>bluewhale</literal> dir and see what happens if we execute Gradle from there.
        </para>
        <para>helloタスクをルートプロジェクトのディレクトリで実行したとき、ビルドは直感に従う、自然な形で実行されました。つまり、サブプロジェクトに定義されたhelloタスクも含め、すべてのhelloタスクが実行されたのです。では、<literal>bluewhale</literal>ディレクトリでGradleを実行した場合、どのようにビルドが実行されるのでしょうか。</para>
        <sample id="multiprojectSubBuild" dir="userguide/multiproject/tropicalWithProperties/water/bluewhale" title="サブプロジェクトからビルドを実行する / Running build from subproject">
           <output args='-q hello'/>
        </sample>
        <para role="original">The basic rule behind Gradle's behavior is simple. Gradle looks down the hierarchy, starting with the
            <emphasis>current dir</emphasis>, for tasks with the name
            <literal>hello</literal>
            an executes them. One thing is very important to note. Gradle
            <emphasis>always</emphasis>
            evaluates
            <emphasis>every</emphasis>
            project of the multi-project build and creates all existing task objects. Then, according to the task name
            arguments and the current dir, Gradle filters the tasks which should be executed. Because of Gradle's
            cross project configuration <emphasis>every</emphasis> project has to be evaluated before <emphasis>any</emphasis>
            task gets executed. We will have a closer look at this in the next section. Let's now have our last marine
            example. Let's add a task to <literal>bluewhale</literal> and <literal>krill</literal>.
        </para>
        <para>Gradleがビルドを実行するときの基本的なルールは単純なものです。この例では、Gradleは<literal>hello</literal>タスクを探して、カレントディレクトリからプロジェクト階層を降りていき、タスクを見つけるとそれを実行するだけです。ただし、非常に重要な注意点が一つあります。Gradleはマルチプロジェクトに参加している<emphasis>すべての</emphasis>プロジェクトを<emphasis>常に</emphasis>評価します。ビルドスクリプトに定義されているタスクオブジェクトは、すべて作成されるのです。そのあと、Gradleは実行時にコマンドに引き渡したタスク名と実行ディレクトリによって、実際に実行するタスクをフィルタリングします。Gradleのクロスプロジェクト設定を実現するため、すべてのプロジェクトはタスク実行前に評価されてなければなりません。次の節では、このことについてさらに詳しく見ていきます。さて、これまで作成してきた<literal>marine</literal>プロジェクトの<literal>bluewhale</literal>と<literal>krill</literal>に新しいタスクを追加しましょう。</para>
        <sample id="multiprojectPartialTasks" dir="userguide/multiproject/partialTasks/water" title="プロジェクトの評価と実行 / Evaluation and execution of projects">
            <sourcefile file="bluewhale/build.gradle"/>
            <sourcefile file="krill/build.gradle"/>
            <output args="-q distanceToIceberg"/>
        </sample>
        <para role="original">Here the output without the <literal>-q</literal> option:</para>
        <para><literal>-q</literal>オプションを外すと、出力結果は以下のようになります。:</para>
        <sample id="multiprojectPartialTasksNotQuiet" dir="userguide/multiproject/partialTasks/water" title="プロジェクトの評価と実行 / Evaluation and execution of projects">
            <output args="distanceToIceberg"/>
        </sample>
        <para role="original">The build is executed from the <literal>water</literal> project. Neither <literal>water</literal> nor
            <literal>tropicalFish</literal> have a task with the name <literal>distanceToIceberg</literal>. Gradle does
            not care. The simple rule mentioned already above is: Execute all tasks down the hierarchy which have this
            name. Only complain if there is <emphasis>no</emphasis> such task!
        </para>
        <para>このビルドは<literal>water</literal>プロジェクトのディレクトリで実行しています。<literal>water</literal>プロジェクトも<literal>tropicalFish</literal>プロジェクトもdistanceToIcebergという名前のタスクは持っていませんが、Gradleはそんなこと気にしません。前述の実行ルールに従って、プロジェクト階層にあるdistanceToIcebergという名前のタスクをすべて実行するだけです。distanceToIcebergタスクが一つもないときだけ警告を出してきます。</para>
    </section>
    <section id='sec:running_partial_build_from_the_root'>
        <title>絶対パスによるタスクの実行<phrase role="original">Running tasks by their absolute path</phrase></title>
        <para role="original">As we have seen, you can run a multi-project build by entering any subproject dir and execute the build
            from there. All matching task names of the project hierarchy starting with the current dir are executed. But
            Gradle also offers to execute tasks by their absolute path (see also <xref linkend='sec:project_and_task_paths'/>):
        </para>
        <para>いままで見てきたように、マルチプロジェクトのサブプロジェクトは、プロジェクトのディレクトリに移動して個別にビルドできます。その場合、実行ディレクトリ以下の、指定したタスク名のタスクがすべて実行されます。また、ビルド時にタスクの絶対パスを指定することもできます。ディレクトリを移動しなくても、パスで指定したプロジェクトのタスクのみ実行できるのです。(<xref linkend='sec:project_and_task_paths'/>もご参照ください)</para>
        <sample id="multiprojectAbsoluteTaskPaths" dir="userguide/multiproject/tropicalWithProperties/water/tropicalFish" title="絶対パスによるタスクの実行 / Running tasks by their absolute path">
            <output args="-q :hello :krill:hello hello"/>
        </sample>
        <para role="original">The build is executed from the <literal>tropicalFish</literal> project. We execute the <literal>hello</literal>
            tasks of the <literal>water</literal>, the <literal>krill</literal> and the <literal>tropicalFish</literal>
            project. The first two tasks are specified by there absolute path, the last task is executed on the name
            matching mechanism described above.
        </para>
        <para>ビルドは<literal>tropicalFish</literal>プロジェクトのディレクトリで実行されています。上記の例では、ルートプロジェクト<literal>watar</literal>、<literal>krill</literal>プロジェクト、そしてカレントのサブプロジェクト<literal>tropicalFish</literal>の<literal>hello</literal>がそれぞれ実行されます。</para>
    </section>
    <section id='sec:project_and_task_paths'>
        <title>プロジェクトとタスクのパス<phrase role="original">Project and task paths</phrase></title>
        <para role="original">A project path has the following pattern: It starts always with a colon, which denotes the root project.
            The root project is the only project in a path that is not specified by its name. The path
            <literal>:bluewhale</literal>
            corresponds to the file system path
            <literal>water/bluewhale</literal>
            in the case of the example above.
        </para>
        <para>プロジェクトのパスは、ルートプロジェクトを表すコロンで始まります。ルートプロジェクトはパス内では名前が指定されません。<literal>:bluewhale</literal>はファイルシステムで言えば「water/bluewhale」に対応します。</para>
        <para role="original">The path of a task is simply its project path plus the task name. For example <literal>
            :bluewhale:hello</literal>. Within a project you can address a task of the same project just by its name.
            This is interpreted as a relative path.
        </para>
        <para>タスクのパスは、単純にプロジェクトパスにタスク名を加えるだけです(例 <literal>:bluewhale:hello</literal>)。なお、カレントのプロジェクトにあるタスクは、タスク名だけで指定できます。これは、絶対パスに対して、相対パスと考えることができます。</para>
        <para role="original">Originally Gradle has used the
            <literal>'/'</literal>
            character as a natural path separator. With the introduction of directory tasks (see <xref
                    linkend='sec:directory_creation'/>) this was no longer possible, as the name of the directory task
            contains the
            <literal>'/'</literal>
            character.
        </para>
        <para>以前Gradleでは、プロジェクトのパスセパレータとして<literal>「/」</literal>を使用していました。しかし、このセパレータ文字は<literal>directory</literal>タスク(<xref linkend='sec:directory_creation'/>参照)が導入されたときに廃止されています。<literal>directory</literal>タスクのタスク名に、<literal>「/」</literal>が含まれるためです。</para>
    </section>
    <section id='sec:dependencies_which_dependencies'>
        <title>依存関係 - なんの依存関係？<phrase role="original">Dependencies - Which dependencies?</phrase></title>
        <para role="original">The examples from the last section were special, as the projects had no <emphasis>Execution
            Dependencies</emphasis>. They had only <emphasis>Configuration Dependencies</emphasis>. Here is an example
            where this is different:
        </para>
        <para>先ほどまでの例は特殊なもので、プロジェクトの間で設定情報は依存関係がありましたが、実行に関しては依存関係がありませんでした。ここでは、実行の依存関係について見てきます。</para>
        <section id='sub:execution_time_dependencies'>
            <title>実行に関する依存関係<phrase role="original">Execution dependencies</phrase></title>
            <section id='ssub:dependencies_and_execution_order'>
                <title>依存関係と実行順序<phrase role="original">Dependencies and execution order</phrase></title>
                <sample id="multiprojectFirstMessages" dir="userguide/multiproject/dependencies/firstMessages/messages" includeLocation="true" title="依存関係とビルド実行順序 / Dependencies and execution order">
                    <layout>
                        settings.gradle
                        consumer/build.gradle
                        producer/build.gradle
                    </layout>
                    <sourcefile file="settings.gradle"/>
                    <sourcefile file="consumer/build.gradle"/>
                    <sourcefile file="producer/build.gradle"/>
                    <output args="-q action"/>
                </sample>
                <para role="original">This did not work out. If nothing else is defined, Gradle executes the task in alphanumeric order.
                    Therefore
                    <literal>:consumer:action</literal>
                    is executed before <literal>:producer:action</literal>. Let's try to solve this with a hack and
                    rename the producer project to <literal>aProducer</literal>.
                </para>
                <para>この例はうまく動作しません。依存関係が定義されていないと、Gradleはタスクをアルファベット順に実行します。したがって、<literal>:consumer(消費者):action</literal>が<literal>:producer(供給者):action</literal>より先に実行されてしまうのです。<literal>producer</literal>プロジェクトの名前を<literal>aProducer</literal>に修正すればこの問題を解決することはできます。</para>
                <sample id="multiprojectMessagesHack" dir="userguide/multiproject/dependencies/messagesHack/messages" title="依存関係とビルド実行順序 / Dependencies and execution order">
                    <layout>
                        settings.gradle
                        aProducer/build.gradle
                        consumer/build.gradle
                    </layout>
                    <sourcefile file="settings.gradle"/>
                    <sourcefile file="aProducer/build.gradle"/>
                    <sourcefile file="consumer/build.gradle"/>
                    <output args="-q action"/>
                </sample>
                <para role="original">Now we take the air out of this hack. We simply switch to the <literal>consumer</literal> dir and
                    execute the build.
                </para>
                <para>ただ、このハックは簡単に破綻してしまいます。consumerディレクトリに移動して、ビルドしてみましょう。</para>
                <sample id="multiprojectMessagesHackBroken" dir="userguide/multiproject/dependencies/messagesHack/messages/consumer" title="依存関係とビルド実行順序 / Dependencies and execution order">
                    <output args="-q action"/>
                </sample>
                <para role="original">For Gradle the two
                    <literal>action</literal>
                    tasks are just not related. If you execute the build from the
                    <literal>messages</literal>
                    project Gradle executes them both because they have the same name and they are down the hierarchy.
                    In the last example only one
                    <literal>action</literal>
                    was down the hierarchy and therefore it was the only task that got executed. We need something
                    better than this hack.
                </para>
                <para>結局、Gradleにとってこの二つのタスクはなんの関係もない別個のタスクにすぎません。確かに、<literal>messages</literal>プロジェクトをビルドすればGradleはこの二つのタスクを両方とも実行します。しかし、それは二つのタスクが同じ名前のタスクであり、両方とも実行ディレクトリ以下にあるからです。最後の例では一方のタスクが実行ディレクトリから外れたので、片方のタスクしか実行されませんでした。依存関係を定義するには、それに適した方法が必要になります。</para>
            </section>
            <section id='ssub:declaring_dependencies'>
                <title>依存関係を宣言する<phrase role="original">Declaring dependencies</phrase></title>
                <sample id="multiprojectMessagesDependencies" dir="userguide/multiproject/dependencies/messagesWithDependencies/messages" includeLocation="true" title="依存関係を宣言する">
                    <layout>
                        settings.gradle
                        consumer/build.gradle
                        producer/build.gradle
                    </layout>
                    <sourcefile file="settings.gradle"/>
                    <sourcefile file="consumer/build.gradle"/>
                    <sourcefile file="producer/build.gradle"/>
                    <output args="-q action"/>
                </sample>
                <para role="original">Running this from the <literal>consumer</literal> directory gives:</para>
                <para><literal>consumer</literal>ディレクトリでビルドすると、以下のようになります。</para>
                <sample id="multiprojectMessagesDependenciesSubBuild" dir="userguide/multiproject/dependencies/messagesWithDependencies/messages/consumer" title="依存関係を宣言する">
                    <output args="-q action"/>
                </sample>
                <para role="original">We have now declared that the
                    <literal>action</literal> task in the <literal>consumer</literal>
                    project has an
                    <emphasis>execution dependency</emphasis>
                    on the <literal>action</literal> task on the
                    <literal>producer</literal>
                    project.
                </para>
                <para><literal>consumer</literal>プロジェクトは<literal>producer</literal>プロジェクトの実行に依存することを宣言しました。プロジェクト間の実行依存の宣言はGradleの構文糖衣で、実際にはタスク間の実行依存を作成しています。タスクの絶対パスを使って、プロジェクト間にまたがるタスクの実行依存関係を手で定義することもできます。</para>
            </section>
            <section id='ssub:the_nature_of_cross_project_task_dependencies'>
                <title>プロジェクトをまたぐタスク間依存関係の性質 <phrase role="original">The nature of cross project task dependencies</phrase></title>
                <para role="original">Of course, task dependencies across different projects are not limited to tasks with the same name.
                    Let's change the naming of our tasks and execute the build.
                </para>
                <para>
                    もちろん、同じ名前のタスク間でしかプロジェクトをまたぐ依存関係は結べない、ということはありません。
                    タスクの名前を変えて実行してみたのが、以下の例です。
                </para>
                <sample id="multiprojectMessagesTaskDependencies" dir="userguide/multiproject/dependencies/messagesTaskDependencies/messages" title="プロジェクトにまたがるタスク間の依存関係 / Cross project task dependencies">
                    <sourcefile file="consumer/build.gradle"/>
                    <sourcefile file="producer/build.gradle"/>
                    <output args="-q consume"/>
                </sample>
            </section>
        </section>
        <section id='sub:configuration_time_dependencies'>
            <title>評価順序の依存関係<phrase role="original">Configuration time dependencies</phrase></title>
            <para role="original">Let's have one more example with our producer-consumer build before we enter
                <emphasis>Java</emphasis>
                land. We add a property to the producer project and create now a configuration time dependency from
                consumer on producer.
            </para>
            <para>そろそろ実際の<emphasis>Java</emphasis>での例をみていきたいと思いますが、その前に、producer-consumerプロジェクトについてもう一つ例を見てみます。ひとつのプロパティをproducerプロジェクトに加えて、consumerプロジェクトから評価順序の依存関係をproducerプロジェクトに作成します。</para>
            <sample id="multiprojectMessagesConfigDependenciesBroken" dir="userguide/multiproject/dependencies/messagesConfigDependenciesBroken/messages" title="評価順序の依存関係 / Configuration time dependencies">
                <sourcefile file="consumer/build.gradle"/>
                <sourcefile file="producer/build.gradle"/>
                <output args="-q consume"/>
            </sample>
            <para role="original">The default
                <emphasis>evaluation</emphasis>
                order of the projects is alphanumeric (for the same nesting level). Therefore the
                <literal>consumer</literal>
                project is evaluated before the
                <literal>producer</literal>
                project and the
                <literal>key</literal>
                value of the
                <literal>producer</literal>
                is set
                <emphasis>after</emphasis>
                it is read by the
                <literal>consumer</literal>
                project. Gradle offers a solution for this.
            </para>
            <para>デフォルトでは、プロジェクトはプロジェクト名のアルファベット順で評価されます。したがって、<literal>consumer</literal>プロジェクトは<literal>producer</literal>プロジェクトの前に評価され、<literal>producer</literal>プロジェクトのプロパティは<literal>consumer</literal>プロジェクトが読みにいった後にセットされてしまうのです。Gradleでは、このような問題に対する解決策を提供しています。</para>
            <sample id="multiprojectMessagesConfigDependencies" dir="userguide/multiproject/dependencies/messagesConfigDependencies/messages" title="評価順序の依存関係 - evaluationDependsOn / Configuration time dependencies - evaluationDependsOn">
                <sourcefile file="consumer/build.gradle"/>
                <output args="-q consume"/>
            </sample>
            <para role="original">The command
                <literal>evaluationDependsOn</literal>
                triggers the evaluation of
                <literal>producer</literal>
                <emphasis>before</emphasis>
                <literal>consumer</literal>
                is evaluated. The example is a bit contrived for the sake of showing the mechanism. In
                <emphasis>this</emphasis>
                case there would be an easier solution by reading the key property at execution time.
            </para>
            <para>この<literal>evaluationDependsOn</literal>コマンドにより、<literal>producer</literal>プロジェクトが<literal>consumer</literal>の前に評価されるようになります。なお、この例はメカニズムを説明するためのやや不自然なものです。この場合は実行時にタスク内でプロパティを読みにいった方が早いでしょう。</para>
            <sample id="multiprojectMessagesConfigDependenciesAltSolution" dir="userguide/multiproject/dependencies/messagesConfigDependenciesAltSolution/messages" title="評価順序の依存関係 / Configuration time dependencies">
                <sourcefile file="consumer/build.gradle"/>
                <output args="-q consume"/>
            </sample>
            <para role="original">Configuration dependencies are very different to execution dependencies. Configuration dependencies
                are between projects whereas execution dependencies are always resolved to task dependencies. Another
                difference is that always all projects are configured, even when you start the build from a subproject.
                The default configuration order is top down, which is usually what is needed.
            </para>
            <para>評価順序の依存関係と実行時の依存関係では、大きく異なる点があります。まず、実行の依存関係は最終的には常にタスク間の依存関係になりますが、評価順序の依存関係はプロジェクト間の依存関係です。さらに、サブプロジェクトを始点にビルドを開始した場合でも、そのマルチプロジェクトに含まれる全てのプロジェクトが評価されるという違いもあります。デフォルトでは、ルートプロジェクトからトップダウンでサブプロジェクトに向かって評価されていきます。普通はその順序で評価する必要があるからです。</para>
            <para role="original">
                To change the the default configuration order to be bottom up, That means that a project configuration
                depends on the configuration of its child projects, the <literal>evaluationDependsOnChildren()</literal> method can be used.
            </para>
            <para>このデフォルトを変更してボトムアップで評価されるようにするには、つまり、あるプロジェクトの設定値が、子プロジェクトの設定値に依存している場合は、<literal>evaluationDependsOnChildren()</literal>メソッドを使ってください。</para>
            <para role="original">On the same nesting level the configuration order depends on the alphanumeric position. The most
                common use case is to have multi-project builds that share a common lifecycle (e.g. all projects use the
                Java plugin). If you declare with
                <literal>dependsOn</literal>
                a
                <emphasis>execution dependency</emphasis>
                between different projects, the default behavior of this method is to create also a
                <emphasis>configuration</emphasis>
                dependency between the two projects. Therefore it is likely that you don't have to define configuration
                dependencies explicitly.
            </para>
            <para>同じ階層にあるプロジェクトは、プロジェクト名のアルファベット順で評価されます。よく使われるのは、マルチプロジェクトに参加しているプロジェクトの間で、同じビルドサイクルを共有させるときです(すべてのプロジェクトがJavaプラグインを使うなど)。プロジェクト間に実行の依存関係を定義すると、評価順序の依存関係も同様に定義されます。したがって、評価順序の依存関係を明示的に指定することはあまりないかもしれません。</para>
        </section>
        <section id='sub:real_life_examples'>
            <title>実生活での例<phrase role="original">Real life examples</phrase></title>
            <para role="original">Gradle's multi-project features are driven by real life use cases. The first example for describing
                such a use case, consists of two webapplication projects and a parent project that creates a
                distribution out of them.
                <footnote>
                    <para role="original">The real use case we had, was using <ulink url='http://lucene.apache.org/solr'/>, where you
                        need a separate war for each index you are accessing. That was one reason why we have created a
                        distribution of webapps. The Resin servlet container allows us, to let such a distribution point
                        to a base installation of the servlet container.
                    </para>
                </footnote>
                For the example we use only one build script and do <emphasis>cross project configuration</emphasis>.
            </para>
            <para>Gradleのマルチプロジェクト機能は、開発現場でのユースケースに基づいて作成されています。ここではそのようなユースケースの例として、二つのWebアプリケーションとそれらの配布物を作成する親プロジェクトを紹介します。
                <footnote>
                    <para>実際のケースでは<ulink url='http://lucene.apache.org/solr'/>を使っており、warファイルをアクセスするインデックスごとに分割する必要がありました。分散型のウェブアプリケーションを作成したひとつの理由はそれです。サーブレットコンテナResinはそのような分散させたWebアプリケーションを、ベースとなるサーブレットコンテナをポイントするよう設定することができます。</para>
                </footnote>
この例では、<emphasis>クロスプロジェクト設定</emphasis>を使って、一つのビルドスクリプトですべてのプロジェクトの設定を行っています。</para>
            <sample id="webdist" dir="userguide/multiproject/dependencies/webDist" includeLocation="true" title="依存関係 - 実生活の例 - クロスプロジェクト設定 / Dependencies - real life example - crossproject configuration">
                <layout>
                    settings.gradle
                    build.gradle
                    date/
                    date/src/main/java/
                    date/src/main/java/org/gradle/sample/DateServlet.java
                    hello/
                    hello/src/main/java/
                    hello/src/main/java/org/gradle/sample/HelloServlet.java
                </layout>
                <sourcefile file="settings.gradle"/>
                <sourcefile file="build.gradle"/>
            </sample>
            <para role="original">We have an interesting set of dependencies. Obviously the
                <literal>date</literal>
                and
                <literal>hello</literal>
                projects have a
                <emphasis>configuration</emphasis>
                dependency on <literal>webDist</literal>, as all the build logic for the webapp projects is injected by
                <literal>webDist</literal>. The
                <emphasis>execution</emphasis>
                dependency is in the other direction, as
                <literal>webDist</literal>
                depends on the build artifacts of
                <literal>date</literal>
                and <literal>hello</literal>. There is even a third dependency.
                <literal>webDist</literal>
                has a
                <emphasis>configuration</emphasis>
                dependency on
                <literal>date</literal>
                and
                <literal>hello</literal>
                because it needs to know the <literal>archivePath</literal>. But it asks for this information at
                <emphasis>execution time</emphasis>. Therefore we have no circular dependency.
            </para>
            <para>この例は、面白い依存関係を持っています。<literal>date</literal>プロジェクトと<literal>hello</literal>プロジェクトで定義されているタスクの<emphasis>評価</emphasis>は、明らかに<literal>webDist</literal>の<emphasis>評価</emphasis>に依存しています。Webアプリのビルドロジックは、すべてwebDistによって注入されているからです。しかし、実行の依存関係はそれとは逆です。<literal>webDist</literal>は<literal>hello</literal>と<literal>date</literal>の成果物を使ってビルドされるからです。さらに、もう一つの依存関係があります。webDistプロジェクトの評価は、dateとhelloの評価に依存しています。なぜなら、それらのプロジェクトのarchivePathプロパティの値を知る必要があるからです。ただ、この問い合わせは実行時に行われていて、依存関係が循環しているわけではありません。</para>
            <para role="original">Such and other dependency patterns are daily bread in the problem space of multi-project builds. If a
                build system does not support such patterns, you either can't solve your problem or you need to do ugly
                hacks which are hard to maintain and massively afflict your productivity as a build master.
            </para>
            <para>この手の依存関係は、マルチプロジェクトのビルドではよく発生します。ビルドシステムがこのような依存関係に対応できなければ、解決できない問題が発生したり、苦し紛れのハックを行うハメになるでしょう。ビルドのメンテナンスが難しくなり、ビルドの管理者として生産性を大きく落としてしまうことになりかねません。</para>
        </section>
    </section>
    <section id='sec:project_jar_dependencies'>
        <title>プロジェクト依存関係<phrase role="original">Project lib dependencies</phrase></title>
        <para role="original">What if one projects needs the jar produced by another project in its compile path? And not just the jar
            but also the transitive dependencies of this jar? Obviously this is a very common use case for Java
            multi-project builds. As already mentioned in <xref linkend='sub:project_dependencies'/>, Gradle
            offers project lib dependencies for this.
        </para>
        <para>あるプロジェクトが、別のプロジェクトの生成するjarをコンパイルするときのクラスパスに必要としていたらどうすればいいのでしょう。さらに、単にjarだけでなく、そのjarが依存する他のライブラリも必要だとしたら？ これは、Javaのマルチプロジェクトではいかにもよくありそうなパターンです。<xref linkend='sub:project_dependencies'/>ですでに言及していますが、プロジェクト依存関係はこのようなケースに対応するものです。</para>
        <sample id="javadependencies_1" dir="userguide/multiproject/dependencies/java" includeLocation="true" title="プロジェクト依存関係 / Project lib dependencies">
            <layout>
                settings.gradle
                build.gradle
                api/
                api/src/main/java/
                api/src/main/java/org/gradle/sample/api/Person.java
                api/src/main/java/org/gradle/sample/apiImpl/PersonImpl.java
                services/personService/
                services/personService/src/main/java/
                services/personService/src/main/java/org/gradle/sample/services/PersonService.java
                services/personService/src/test/java/
                services/personService/src/test/java/org/gradle/sample/services/PersonServiceTest.java
                shared/
                shared/src/main/java/
                shared/src/main/java/org/gradle/sample/shared/Helper.java
            </layout>
        </sample>
        <para role="original">We have the projects <literal>shared</literal>, <literal>api</literal> and<literal>personService</literal>.
            <literal>personService</literal> has a lib dependency on the other two projects. <literal>api</literal>
            has a lib dependency on <literal>shared</literal>.
            <footnote>
                <para role="original">
                    <literal>services</literal>
                    is also a project, but we use it just as a container. It has no build script and gets nothing
                    injected by another build script.
                </para>
            </footnote>
        </para>
        <para><literal>shared</literal>、<literal>api</literal>、<literal>personService</literal>の三つのプロジェクトがあります。<literal>personService</literal>プロジェクトは他の二つのプロジェクトに依存しています。さらに、<literal>api</literal>プロジェクトは<literal>shared</literal>プロジェクトに依存しています。
            <footnote>
                <para><literal>services</literal>もまたプロジェクトですが、これはただの入れ物です。このプロジェクトにはビルドスクリプトも別のプロジェクトから注入される設定もありません。</para>
            </footnote>
        </para>
        <sample id="javadependencies_2" dir="userguide/multiproject/dependencies/java" title="プロジェクト依存関係 / Project lib dependencies">
            <sourcefile file="settings.gradle"/>
            <sourcefile file="build.gradle"/>
        </sample>
        <para role="original">All the build logic is in the
            <literal>build.gradle</literal> of the root project.
            <footnote>
                <para role="original">We do this here, as it makes the layout a bit easier. We usually put the project specific stuff
                    into the build script of the respective projects.
                </para>
            </footnote>
            A <emphasis>lib</emphasis>
            dependency is a special form of an execution dependency. It causes the other project to be built first and
            adds the jar with the classes of the other project to the classpath. It also adds the dependencies of the
            other project to the classpath. So you can enter the
            <literal>api</literal>
            directory and trigger a <userinput>gradle compile</userinput>. First
            <literal>shared</literal>
            is built and then
            <literal>api</literal>
            is built. Project dependencies enable partial multi-project builds.
        </para>
        <para>ビルドロジックはすべてルートプロジェクトの<filename>build.gradle</filename>に記述されています。
            <footnote>
                <para>この例では、ビルドスクリプトの配置を少し簡易化しています。普通は、プロジェクトが指定するものはそのプロジェクトのビルドスクリプトに記述します。</para>
            </footnote>
プロジェクト依存関係は、実行依存の別形態といえます。まずあるプロジェクトのビルドを実行し、生成されたクラスをjarに格納して、そのプロジェクトに依存しているプロジェクトのクラスパスに追加するのです。さらに、そのプロジェクトの依存関係も同時にクラスパスに追加します。apiディレクトリに移動して、<command>gradle compile</command>と入力してみましょう。まず<literal>shared</literal>がビルドされ、次に<literal>api</literal>がビルドされるでしょう。プロジェクト依存はマルチプロジェクトの部分ビルドを可能にします。</para>
        <para role="original">If you come from Maven land you might be perfectly happy with this. If you come from Ivy land, you might
            expect some more fine grained control. Gradle offers this to you:
        </para>
        <para>Mavenを使用されてきた人なら、このことですごく満足できるでしょう。Ivyの経験をお持ちなら、もっと細かい制御を期待するかもしれません。Gradleでは、次のようにします。</para>
        <sample id="javaWithCustomConf" dir="userguide/multiproject/dependencies/javaWithCustomConf" title="細かい依存関係の制御 / Fine grained control over dependencies">
            <sourcefile file="build.gradle"/>
        </sample>
        <para role="original">The Java plugin adds per default a jar to your project libraries which contains all the classes. In this
            example we create an
            <emphasis>additional</emphasis>
            library containing only the interfaces of the
            <literal>api</literal>
            project. We assign this library to a new <emphasis>dependency configuration</emphasis>. For the person
            service we declare that the project should be compiled only against the
            <literal>api</literal>
            interfaces but tested with all classes from <literal>api</literal>.
        </para>
        <para>Javaプラグインは、デフォルトではすべてのクラスが含まれたjarをプロジェクトのライブラリとして追加しますが、ここでは<emphasis>それに加えて</emphasis>、apiプロジェクトのインターフェースのみが含まれたライブラリを作成しています。そしてこのライブラリを、新規に作成した、依存関係のコンフィギュレーション(spi)に割り当てています。person serviceをコンパイルするときはインターフェースしか要りませんが、テストをするにはapiからすべてのクラスを持ってくる必要があるのです。</para>
        <section id="disable_dependency_projects">
            <title>依存プロジェクトをビルドしないようにする<phrase role="original">Disabling the build of dependency projects</phrase></title>
            <para role="original">Sometimes you don't want depended on projects to be built when doing a partial build.
                To disable the build of the depended on projects you can run Gradle with the <code>-a</code> option.
            </para>
            <para>部分ビルドを実行する際、依存しているプロジェクトはビルドしたくない、という場合もあるかもしれません。依存しているプロジェクトのビルドを無効化するには、<option>-a</option>オプションをつけてプロジェクトをビルドしてください。</para>
        </section>
    </section>
    <section id="sec:parallel_execution">
        <title>Parallel project execution</title>
        <para>With more and more CPU cores available on developer desktops and CI servers,
            it is important that Gradle is able to fully utilise these processing resources.
            More specifically, the parallel execution attempts to:
            <itemizedlist>
                <listitem>Reduce total build time for a multi-project build where execution is IO bound or otherwise does not consume all available CPU resources.</listitem>
                <listitem>Provide faster feedback for execution of small projects without awaiting completion of other projects.</listitem>
            </itemizedlist>
            Although Gradle already offers parallel test execution via <apilink class="org.gradle.api.tasks.testing.Test" method="setMaxParallelForks"/>
            the feature described in this section is parallel execution at a project level.
            Parallel execution is an incubating feature. Please use it and let us know how it works for you.
        </para>
        <para>
            Parallel project execution allows the separate projects in a decoupled multi-project build to be executed in parallel
            (see also: <xref linkend="sec:decoupled_projects"/>).
            While parallel execution does not strictly require decoupling at configuration time,
            the long-term goal is to provide a powerful set of features that will be available for fully decoupled projects.
            Such features include:
            <itemizedlist>
                <listitem><xref linkend="sec:configuration_on_demand"/>.</listitem>
                <listitem>Configuration of projects in parallel.</listitem>
                <listitem>Re-use of configuration for unchanged projects.</listitem>
                <listitem>Project-level up-to-date checks.</listitem>
                <listitem>Using pre-built artifacts in the place of building dependent projects.</listitem>
            </itemizedlist>
        </para>
        <para>
            How does the parallel execution work? First, you need to tell Gradle to use the parallel mode.
            You can use the command line argument (<xref linkend='gradle_command_line'/>) or configure your build environment (<xref linkend="sec:gradle_configuration_properties"/>).
            Unless you provide specific number of parallel threads Gradle attempts to choose the right number based on available CPU cores.
            Every parallel worker exclusively owns a given project while executing a task.
            This means that 2 tasks from the same project are never executed in parallel.
            Therefore only multi-project builds can take advantage of parallel execution.
            Task dependencies are fully supported and parallel workers will start executing upstream tasks first.
            Bear in mind that the alphabetical scheduling of decoupled tasks, known from the sequential execution, does not really work in parallel mode.
            You need to make sure the task dependencies are declared correctly to avoid ordering issues.
        </para>
    </section>
    <section id="sec:decoupled_projects">
        <title>分離されたプロジェクト <phrase role="original">Decoupled Projects</phrase></title>
        <para role="original">Gradle allows any project to access any other project during both the configuration and execution phases. While this provides a great deal of power
            and flexibility to the build author, it also limits the flexibility that Gradle has when building those projects. For instance, this tight <emphasis>coupling</emphasis> of projects
            effectively prevents Gradle from building multiple projects in parallel, or from substituting a pre-built artifact in place of a project dependency.
        </para>
        <para>
            Gradleでは、評価フェーズでも実行フェーズでも、あらゆるプロジェクト間でお互いにアクセスすることができるようになっています。
            これはビルドの作成者にとっては非常に強力で柔軟性のある仕様ですが、ビルド時にはGradleの方の柔軟性が制限されることになります。
            例を挙げると、強固に結合されたプロジェクトは、Gradleに平行ビルドさせることができませんし、依存プロジェクトの代わりにビルド済みのアーティファクトを使用することもできません。
        </para>
        <para role="original">Two projects are said to be <emphasis>decoupled</emphasis> if they do not directly access each other's project model. Decoupled projects may only interact in terms of
            declared dependencies: project dependencies (<xref linkend='sub:project_dependencies'/>) and/or task dependencies (<xref linkend='sec:task_dependencies'/>).
            Any other form of project interaction (i.e. by modifying another project object or by reading a value from another project object) causes the projects to
            be coupled.
        </para>
        <para>
            お互いのプロジェクト・モデルにアクセスしない二つのプロジェクトは、<emphasis>分離された</emphasis>プロジェクトと呼ばれます。
            分離されたプロジェクトでは、お互いのやりとりに依存関係宣言のみを使用します。つまり、プロジェクト依存(<xref linkend='sub:project_dependencies'/>)やタスク依存(<xref linkend='sec:task_dependencies'/>)です。
            その他のあらゆるアクセス、例えば他プロジェクトのオブジェクトを変更したり、設定値を読み込んだりといった処理は、全てプロジェクトを<emphasis>結合</emphasis>させます。
        </para>
        <para role="original">
            A very common way for projects to be coupled is by using configuration injection (<xref linkend='sec:cross_project_configuration'/>). It may not be immediately apparent, but using key
            Gradle features like the <literal>allprojects</literal> and <literal>subprojects</literal> keywords automatically cause your projects to be coupled. This is
            because these keywords are used in a <literal>build.gradle</literal> file, which defines a project. Often this is a "root project" that does nothing more than
            define common configuration, but as far as Gradle is concerned this root project is still a fully-fledged project, and by using <literal>allprojects</literal>
            that project is effectively coupled to all other projects.
        </para>
        <para>
        プロジェクトが結合されるもっとも一般的な状況は、設定のインジェクション(<xref linkend='sec:cross_project_configuration'/>)です。
        これは直ぐには分かりにくいかもしれませんが、<literal>allprojects</literal>や<literal>subprojects</literal>キーワードのような、Gradleの特定の機能を使うと、プロジェクトは自動的に結合されます。
        これらのキーワードは、<literal>build.gradle</literal>ファイルで別のプロジェクトを定義するのに使われるからです。
        共通設定の定義しかしていないルートプロジェクトもよくありますが、Gradleがルートプロジェクトを、完全な普通のプロジェクトと判断し、さらに<literal>allprojects</literal>を使用している限り、プロジェクトは他の全てのプロジェクトと結合されます。
        </para>
        <para role="original">This means that using any form of shared build script logic or configuration injection (<literal>allprojects</literal>, <literal>subprojects</literal>, etc.)
            will cause your projects to be coupled. As we extend the concept of project decoupling and provide features that take advantage of decoupled projects,
            we will also introduce new features to help you to solve common use cases (like configuration injection) without causing your projects to be coupled.
        </para>
        <para>
        つまり、どんな形であれ、ビルドスクリプトのロジック共有、および設定のインジェクション(<literal>allprojects</literal>や<literal>subprojects</literal>など)は、プロジェクトを結合させるということです。
        私たちは、この分離されたプロジェクトという概念を拡張し、有効活用するような機能を追加する予定です。それにより、設定インジェクションなどの機能を、プロジェクトを結合することなく実現できます。
        </para>
    </section>
    <section id="sec:multiproject_build_and_test">
        <title>マルチプロジェクトのビルドとテスティング<phrase role="original">Multi-Project Building and Testing</phrase></title>
        <para role="original">The <literal>build</literal> task of the Java plugin is typically used to compile, test, and perform
            code style checks (if the CodeQuality plugin is used) of a single project.  In multi-project builds
            you may often want to do all of these tasks across a range of projects.  The <literal>buildNeeded</literal>
            and <literal>buildDependents</literal> tasks can help with this.
        </para>
        <para>Javaプラグインの<literal>build</literal>タスクは、シングルプロジェクトをコンパイル、テスト、さらに(CodeQualityプラグインを使っていれば)コードスタイルのチェックも行うという、典型的なビルド処理を実行します。さらに、マルチプロジェクトを構成している場合は、これらのタスクをプロジェクトを横断して実行したい場面もあるでしょう。<literal>buildNeeded</literal>と<literal>buildDependents</literal>はこの用途を助けてくれるものです。</para>
        <para role="original">Let's use the project structure shown in <xref linkend='javadependencies_2'/>.  In this
            example :services:personservice depends on both :api and :shared.  The :api project also depends on
            :shared.
        </para>
        <para><xref linkend='javadependencies_2'/>にあるプロジェクトの構造を使いましょう。この例では:service:personserviceが:apiと:sharedの双方に依存しています。また、:apiは:sharedに依存しています。</para>
        <para role="original">Assume you are working on a single project, the :api project.  You have been making changes, but
            have not built the entire project since performing a clean.  You want to build any necessary supporting
            jars, but only perform code quality and unit tests on the project you have changed.
            The <literal>build</literal> task does this.
        </para>
        <para>シングルプロジェクトの:apiプロジェクトで作業しているとします。:apiに変更を加えましたが、クリーン以降、まだプロジェクト全体のビルドはしていません。jarが必要になってビルドするというとき、コード品質のチェックやユニットテストは自分が変更したプロジェクトでのみ実行したいところです。<literal>build</literal>タスクは、まさにこの処理を行います。</para>
        <sample id="multitestingBuild" dir="userguide/multiproject/dependencies/java" title="シングルプロジェクトのビルドとテスト / Build and Test Single Project">
            <output args=":api:build"/>
        </sample>

        <para role="original">While you are working in a typical development cycle repeatedly building and testing changes to
            the :api project (knowing that you are only changing files in this one project), you may not want to
            even suffer the expense of :shared:compile checking to see what has changed in the :shared project.
            Adding the <literal>-a</literal> option will cause Gradle to use cached jars to resolve any project lib
            dependencies and not try to re-build the depended on projects.
        </para>
        <para>典型的な開発サイクルでは、:apiプロジェクトに何か変更を加えるたびビルドとテストを繰り返すことになります。このとき、:shared:compileタスクは、ビルドのたび:sharedプロジェクトが変更されていないか確認しに行きます。:apiプロジェクトしか変更していないことが分かっている場合、このコストさえ苦痛かもしれません。<option>-a</option>オプションをつけてビルドすると、依存プロジェクトのライブラリを解決する際、キャッシュされたjarが使用されるので、依存プロジェクトが再ビルドされることありません。</para>
        <sample id="multitestingBuildDashA" dir="userguide/multiproject/dependencies/java" title="シングルプロジェクトの部分ビルドとテスト / Partial Build and Test Single Project">
            <test args=":shared:assemble"/>
            <output args="-a :api:build"/>
        </sample>

        <para role="original">If you have just gotten the latest version of source from your version control system which included changes
            in other projects that :api depends on, you might want to not only build all the projects you depend on,
            but test them as well. The <literal>buildNeeded</literal> task also tests all the projects from the
            project lib dependencies of the testRuntime configuration.
        </para>
        <para>今、ちょうど最新のソースをバージョン管理システムから持ってきたとしましょう。:apiが依存しているプロジェクトが変更されていました。このとき、依存先の全プロジェクトについて、ビルドだけでなくテストもしたいと考えるかもしれません。<literal>buildNeeded</literal>タスクは、指定したプロジェクトだけでなく、そのプロジェクトのtestRuntime依存関係に設定されているプロジェクトをすべてテストします。</para>
        <sample id="multitestingBuildNeeded" dir="userguide/multiproject/dependencies/java" title="依存プロジェクトのビルドとテスト / Build and Test Depended On Projects">
            <output args=":api:buildNeeded"/>
        </sample>
        <para role="original">You also might want to refactor some part of the :api project that is used in other projects.
            If you make these types of changes, it is not sufficient to test just the :api
            project, you also need to test all projects that depend on the :api project.
            The <literal>buildDependents</literal> task also tests all the projects that have a project lib dependency
            (in the testRuntime configuration) on the specified project.
        </para>
        <para>さらに、:apiプロジェクトをリファクタリングする場合のことを考えてみます。:apiプロジェクトは他のプロジェクトから使用されているので、このプロジェクトだけテストしても十分とは言えません。:apiプロジェクトに依存しているすべてのプロジェクトをテストする必要があります。<literal>buildDependents</literal>タスクは、指定したプロジェクトだけでなく、そのプロジェクトにtestRuntimeのプロジェクト依存関係を持っているすべてのプロジェクトをテストします。</para>
        <sample id="multitestingBuildDependents" dir="userguide/multiproject/dependencies/java" title="依存されているプロジェクトのビルドとテスト / Build and Test Dependent Projects">
            <output args=":api:buildDependents"/>
        </sample>
        <para role="original">Finally, you may want to build and test everything in all projects. Any task you run in the root project folder
        will cause that same named task to be run on all the children. So you can just run
        <literal>gradle build</literal> to build and test all projects.
        </para>
        <para>最後に、すべてのプロジェクトをビルド、テストしたいと思うことがあるかもしれません。ルートプロジェクトのフォルダーでタスクを実行すれば、全ての子プロジェクトでそのタスクと同名のタスクが実行されます。なので、ただ<command>gradle build</command>と実行すれば大丈夫です。すべてのプロジェクトがビルドされテストされます。</para>
    </section>
    <section id='sec:property_and_method_inheritance'>
        <title>プロパティとメソッドの継承<phrase role="original">Property and method inheritance</phrase></title>
        <para role="original">Properties and methods declared in a project are inherited to all its subprojects. This is an alternative
            to configuration injection. But we think that the model of inheritance does not reflect the problem space of
            multi-project builds very well. In a future edition of this user guide we might write more about this.
        </para>
        <para>プロジェクトで宣言されたプロパティとメソッドは、すべての子プロジェクトに継承されます。これは設定のインジェクションの代替手段となるでしょう。ただ、私たちは継承というモデルはマルチプロジェクトの様々な特質を十分に反映できるものではないと考えています。将来バージョンのユーザーガイドでこのことについて詳しく書くつもりです。</para>
        <para role="original">Method inheritance might be interesting to use as Gradle's
            <emphasis>Configuration Injection</emphasis>
            does not support methods yet (but will in a future release).
        </para>
        <para>なお、Gradleの<emphasis>設定のインジェクション</emphasis>ではまだメソッドを注入することができません(将来のリリースで対応する予定です)。なので、メソッドについては継承を使う価値があるかもしれません。</para>
        <para role="original">You might be wondering why we have implemented a feature we obviously don't like that much. One reason is
            that it is offered by other tools and we want to have the check mark in a feature comparison :). And we like
            to offer our users a choice.
        </para>
        <para>どうみても継承機能を敬遠しているのに、なんでそんなのを実装したのか不思議に思われるかもしれません。一つの理由は、継承機能が別のビルドツールで提供されているからです。比較表にチェックマークを付けたかったのです(^^)。また、ユーザーには選択肢を用意したかったというのもあります。</para>
    </section>
    <section>
        <title>まとめ<phrase role="original">Summary</phrase></title>
        <para role="original">Writing this chapter was pretty exhausting and reading it might have a similar effect. Our final message
            for this chapter is that multi-project builds with Gradle are usually
            <emphasis>not</emphasis>
            difficult. There are five elements you need to remember: <literal>allprojects</literal>, <literal>
            subprojects</literal>, <literal>evaluationDependsOn</literal>, <literal>evaluationDependsOnChildren</literal>
            and project lib dependencies.
            <footnote>
                <para role="original">So we are well in the range of the
                    <ulink url='http://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two'>7 plus 2
                        Rule
                    </ulink>
                    :)
                </para>
            </footnote>
            With those elements, and keeping in mind that Gradle has a distinct configuration and execution phase, you
            have already a lot of flexibility. But when you enter steep territory Gradle does not become an obstacle and
            usually accompanies and carries you to the top of the mountain.
        </para>
        <para>この章を書くのは非常に疲れました。読むのも疲れるでしょう。最後にひとつだけ、Gradleでマルチプロジェクトを扱うのは決して難しいことではありません。覚えておく必要があるのは次の5つだけです。<literal>allproject</literal>、<literal>subprojects</literal>、<literal>evaluationDependsOn</literal>、<literal>evaluationDependsOnChildren</literal>、そしてプロジェクト依存関係です。
            <footnote>
                <para>
                    <ulink url='http://ja.wikipedia.org/wiki/%E3%82%B8%E3%83%A7%E3%83%BC%E3%82%B8%E3%83%BB%E3%83%9F%E3%83%A9%E3%83%BC#.E3.83.9E.E3.82.B8.E3.82.AB.E3.83.AB.E3.83.8A.E3.83.B3.E3.83.90.E3.83.BC'>マジカルナンバー7±2</ulink>に収まるナイスな量です
                </para>
            </footnote>
この5つ、そしてGradleが設定フェーズと実行フェーズを別個に取り扱うのだということを覚えておけば、あとは多くの場合融通がききます。もし何らかの困難な問題に突き当たったとしても、Gradleが障害になることもなく、逆にあなたを見晴らしのいい山の上に連れて行ってくれるはずです。</para>
    </section>
</chapter>
