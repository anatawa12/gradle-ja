<!--
  ~ Copyright 2009 the original author or authors.
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->
<chapter id='plugins' xmlns:xi="http://www.w3.org/2001/XInclude"  xml:lang="ja">
    <title>プラグインを使う<phrase role="original">Using Plugins</phrase></title>
    <para role="original">Now we look at <emphasis>how</emphasis> Gradle provides build-by-convention and out of the box functionality.
        These features are decoupled from the core of Gradle, and are provided via plugins. Although the plugins are
        decoupled, we would like to point out that the Gradle core plugins are NEVER updated or changed for a
        particular Gradle distribution. If there is a bug in the compile functionality of Gradle, we will release a new
        version of Gradle. There is no change of behavior for the lifetime of a given distribution of Gradle.
    </para>
    <para>これまで、Gradleが<emphasis>どのように</emphasis>規約によるビルドを提供しているか、およびGradleの標準機能についてみてきました。
        これらの特徴はGradleのコアとは分離されており、プラグインによって提供されています。
        プラグインは分離されていますが、Gradleのコアプラグインは特定のGradle配布物に対して変更されたり更新されたりすることは絶対にないということを指摘しておきたいと思います。
        もしGradleのコンパイル機能にバグがあったら、新しいバージョンのGradleをリリースします。
        特定のGradle配布物の同一バージョン内でふるまいを変えることはありません。
    </para>
    <section id='sec:using_plugins'>
        <title>プラグインの宣言<phrase role="original">Declaring plugins</phrase></title>
        <para role="original">If you want to use the plugin for building a Java project, simply include
        </para>
        <para>Javaプロジェクトのビルドのためにプラグインを使いたいなら、単にスクリプトに以下を追加します。
        </para>
        <sample id="useJavaPlugin" dir="java/quickstart" title="プラグインの利用 / Using a plugin">
            <sourcefile file="build.gradle" snippet="use-plugin"/>
        </sample>
        <para role="original">in your script. That's all. From a technological point of view plugins use just the same
            operations as you can use from your build scripts. That is, they use the Project and Task API.
            The Gradle plugins generally use this API to:
        </para>
        <para>これが全てです。
            技術的な観点からは、プラグインはビルドスクリプトで使うものとまったく同じオペレーションを利用します。
            すなわち、ProjectやTaskのAPIです。
            一般に、Gradleプラグインは次の目的でAPIを利用します:
        </para>
        <itemizedlist>
            <listitem>
                <para role="original">Add tasks to the project (e.g. compile, test)
                </para>
                <para>プロジェクトにタスクを追加する (例: compile, test)
                </para>
            </listitem>
            <listitem>
                <para role="original">Create dependencies between those tasks to let them execute in the appropriate order.
                </para>
                <para>タスクに依存関係を定義して、正しい順序で実行されるようにする
                </para>
            </listitem>
            <listitem>
                <para role="original">Add dependency configurations to the project.</para>
                <para>プロジェクトに依存関係を追加する</para>
            </listitem>
            <listitem>
                <para role="original">Add a so called <firstterm>convention object</firstterm> to the project.
                </para>
                <para>いわゆる<firstterm>規約オブジェクト</firstterm>をプロジェクトに追加する
                </para>
            </listitem>
        </itemizedlist>
        <para role="original">Let's check this out:
        </para>
        <para>これらを見てみましょう:
        </para>
        <sample id="pluginIntro" dir="userguide/tutorial/pluginIntro" title="idでプラグインを適用 / Applying a plugin by id">
            <sourcefile file="build.gradle" snippet="apply-by-id"/>
            <output args="-q show"/>
        </sample>
        <para role="original">The Java plugin adds a <literal>compileJava</literal> task and a <literal>processResources</literal> task
            to the project object which can be accessed by a build script. It has configured the <literal>destinationDir</literal>
            property of both of these tasks.
        </para>
        <para>Javaプラグインはプロジェクトオブジェクトに<literal>compileJava</literal>タスクと<literal>processResources</literal>タスクを追加し、
            ビルドスクリプトからアクセスできるようにします。
            これらのタスクのいずれもプロパティ<literal>destinationDir</literal>を持つように構成されます。
        </para>
        <para role="original">The <literal>apply()</literal> method either takes a string or a class as an argument. You can write
        </para>
        <para><literal>apply()</literal>メソッドは引数として文字列かクラスを受け取ります。次のようにも書けます。
        </para>
        <sample id="pluginIntro" dir="userguide/tutorial/pluginIntro" title="タイプでプラグインを適用 / Applying a plugin by type">
            <sourcefile file="build.gradle" snippet="apply-by-type"/>
        </sample>
        <para role="original">Thanks to Gradle's default imports (see <xref linkend='ide_support'/>) you can also write in this case.
        </para>
        <para>Gradleのデフォルトimportのおかげで(<xref linkend='ide_support'/>参照)、この場合は次のようにも書けます。
        </para>
        <sample id="pluginIntro" dir="userguide/tutorial/pluginIntro" title="タイプでプラグインを適用 / Applying a plugin by type">
            <sourcefile file="build.gradle" snippet="apply-by-type-with-import"/>
        </sample>
        <para role="original">Any class, which implements the <apilink class="org.gradle.api.Plugin"/> interface, can be used as a
            plugin. Just pass the class as an argument. You don't need to configure anything else for this.</para>
        <para><apilink class="org.gradle.api.Plugin"/>インターフェースを実装するクラスであれば何でもプラグインとして利用できます。
            引数としてクラスを渡すだけです。それ以上の設定は何もいりません。</para>
        <para role="original">If you want to use your own plugins, you must make sure that they are accessible via the build script
            classpath (see <xref linkend='organizing_build_logic'/> for more information). To learn more about how
            to write custom plugins, see <xref linkend='custom_plugins'/>.
        </para>
        <para>独自のプラグインを使いたいなら、ビルドスクリプトのクラスパスでアクセス可能なようにしておかなければなりません(詳細は<xref linkend='organizing_build_logic'/>参照)。
            カスタムプラグインの作成方法についての詳細は、<xref linkend='custom_plugins'/>を参照してください。
        </para>
    </section>
    <section id='sub:more_about_convention_objects'>
        <title>規約オブジェクトを使う<phrase role="original">Using the convention object</phrase></title>
        <para role="original">If you use the Java plugin
            for example, there are a <literal>compileJava</literal> and a <literal>processResources</literal> task for
            your production code (the same is true for your test
            code). What if you want to change the default configuration? Let's try:
        </para>
        <para>例えばJavaプラグインを使う場合、プロダクションコードに対して<literal>compileJava</literal>や<literal>processResources</literal>タスクが存在します(テストコードに対しても同じです)。
            デフォルトの設定を変更したいとしたらどうでしょうか。次を試してみてください:
        </para>
        <sample id="pluginConfig" dir="userguide/tutorial/pluginConfig" title="プラグインタスクの設定 / Configuring a plugin task">
            <sourcefile file="build.gradle"/>
            <output args="-q show"/>
        </sample>
        <para role="original">Setting the <literal>destinationDir</literal>
            of the <literal>processResources</literal> task had only an effect on the <literal>processResources</literal>
            task. Maybe this was what you wanted. But what if
            you want to change the output directory for all tasks? It would be unfortunate if you had to do this for
            each task separately.
        </para>
        <para><literal>processResources</literal>タスクの<literal>destinationDir</literal>の設定は、<literal>processResources</literal>タスクに対してのみ有効です。
            これが実際にやりたいことだったらよいのですが、もし全てのタスクに対して出力先ディレクトリを変更したいとしたらどうでしょうか。
            それぞれのタスクに対して別々に設定しなければならないとしたら、それは不幸なことでしょう。
        </para>
        <para role="original">Gradle's tasks are usually <firstterm>convention aware</firstterm>. A plugin can add a convention object to
            your project, and map certain values of this convention object to task properties.
        </para>
        <para>Gradleのタスクは通常、<firstterm>規約を認識</firstterm>します。
            プラグインはプロジェクトに規約オブジェクトを追加でき、規約オブジェクトの特定の値をタスクのプロパティにマップできます。
        </para>
        <sample id="pluginConvention" dir="userguide/tutorial/pluginConvention" title="プラグインの規約オブジェクト / Plugin convention object">
            <sourcefile file="build.gradle"/>
            <output args="-q show"/>
        </sample>
        <para role="original">The Java plugin has added a convention object with a <literal>sourceSets</literal>
            property, which we use to set the classes directory.
        </para>
        <para>Javaプラグインは<literal>sourceSets</literal>プロパティを持つ規約オブジェクトを追加するため、それを使ってclassesディレクトリをセットできます。
        </para>
        <para role="original">By setting a task attribute explicitly (as we have done in the first example) you overwrite the convention
            value for this particular task.
        </para>
        <para>(最初のサンプルのように)タスクの属性を明示的にセットすることで、特定のタスクの規約値を上書きできます。
        </para>
        <para role="original">Not all of the tasks attributes are mapped to convention object values. It is the decision of the plugin
            to decide what are the shared properties and then bundle them in a convention object and map them to the
            tasks.
        </para>
        <para>すべてのタスク属性が規約オブジェクトの値とマップされているわけではありません。
            どのプロパティを共有するか決定して、規約オブジェクトにバンドルし、タスクにマップするかはプラグインが決めることです。
        </para>
        <para role="original">
            The properties of a convention object can be accessed as project properties. As shown in the following
            example, you can also access the convention object explicitly.
        </para>
        <para>
            規約オブジェクトのプロパティは、プロジェクトのプロパティとしてアクセスできます。
            次のサンプルで示すように、明示的に規約オブジェクトにアクセスすることもできます。
        </para>
        <sample id="pluginAccessConvention" dir="userguide/tutorial/pluginAccessConvention" title="プラグインの規約オブジェクトを使う / Using the plugin convention object">
            <sourcefile file="build.gradle"/>
            <output args="-q show"/>
        </sample>
        <para role="original">Every project object has a <apilink class="org.gradle.api.plugins.Convention"/> object which is a
            container for convention objects contributed
            by the plugins declared for your project. If you simply access or set a property or access a method in
            your build script, the project object first looks if this is a property of itself. If not, it delegates
            the request to its convention object. The convention object checks if any of the plugin convention
            objects can fulfill the request (first wins and the order is not defined). The plugin convention objects
            also introduce a namespace.
        </para>
        <para>すべてのプロジェクトオブジェクトは<apilink class="org.gradle.api.plugins.Convention"/>オブジェクトを保持しており、
            これはプロジェクトで宣言したプラグインが提供する規約オブジェクトのコンテナになっています。
            ビルドスクリプト内で単にプロパティへのアクセスやセット、ないしはメソッドへのアクセスを行った場合、
            プロジェクトオブジェクトはまずこれらを自分自身のプロパティとして探索します。
            そうでない場合、要求をプロジェクトの規約オブジェクトに委譲します。
            規約オブジェクトは、プラグインの規約オブジェクトが要求を満たすことができるか確認します(先勝ちで順序は定義されていません)。
            プラグインの規約オブジェクトは名前空間の導入も行います。
        </para>
        <section id='sub:declaring_plugins_multiple_times'>
            <title>重複したプラグイン宣言<phrase role="original">Declaring plugins multiple times</phrase></title>
            <para role="original">A plugin is only called once for a given project, even if you have multiple
                <literal>apply()</literal>
                statements. An additional call after the first call has no effect but doesn't hurt either. This can be
                important if you use plugins which extend other plugins. For example
                the Groovy plugin automatically applies the Java plugin. We say the Groovy plugin extends the Java plugin. But you might as well
                write:
            </para>
            <para>複数の<literal>apply()</literal>文を記述したとしても、指定したプロジェクトに対してプラグインは1回だけ呼び出されます。
                最初の呼び出しの後で追加の呼び出しがあっても、何の効果もなく悪影響も及ぼしません。
                これは、他のプラグインを拡張するプラグインを利用するときに重要になります。
                例えば、Groovyプラグインは自動的にJavaプラグインを適用します。
                つまりGroovyプラグインはJavaプラグインを拡張しているということです。
                しかし、次のように記述して全く問題ありません:
            </para>
            <sample id="pluginIntro" dir="userguide/tutorial/pluginIntro" title="暗黙のプラグインを明示的に適用 / Explicit application of an implied plugin">
                <sourcefile file="build.gradle" snippet="explicit-apply"/>
            </sample>
            <para role="original">If you use cross-project configuration in multi-project builds this is a useful feature.
            </para>
            <para>マルチプロジェクトビルドでプロジェクト横断的なコンフィグレーションを利用するとき、この特徴は役に立ちます。
            </para>
        </section>
    </section>
</chapter>
