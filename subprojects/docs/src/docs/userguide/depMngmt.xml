<!--
  ~ Copyright 2009 the original author or authors.
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->
<chapter id='dependency_management' xmlns:xi="http://www.w3.org/2001/XInclude">
    <title>依存関係の管理<phrase role="original">Dependency Management</phrase></title>
    <section id='sec:Introduction'>
        <title>はじめに<phrase role="original">Introduction</phrase></title>
        <para role="original">This chapter gives an overview of issues related with dependency management and presents how Gradle can be used to overcome them.
        </para>
        <para>この章では、依存関係の管理にまつわる様々な課題について概観し、Gradleがそれらをどのように解決しているか解説します。</para>
        <para role="original">Gradle offers a very good support for dependency management. If you are familiar with Maven or Ivy approach you will be delighted to learn that:
        </para>
        <para>
        Gradleは、依存関係の管理についてとても充実したサポートを提供しています。MavenやIvyでの依存関係管理に明るい方なら、Gradleで次のことができると聞いて嬉しくなるでしょう。
        </para>
        <itemizedlist>
            <listitem>
                <para role="original">All the concepts that you already know and like are still there and are fully supported by Gradle. The current dependency management solutions all require to work with XML descriptor files and are usually
        based on remote repositories for downloading the dependencies. Gradle fully supports this approach.
                </para>
                <para>依存関係管理については既に慣れ親しまれている概念があるのですが、Gradleはその概念を完全な形でサポートしています。現在使われている依存関係の管理方法はすべて、XML形式のメタデータを使用し、(一般的には)リモートリポジトリから依存関係をダウンロードしてくるものです。この方法を、Gradleでも使用することができるのです。</para>
            </listitem>
            <listitem>
                <para role="original">Gradle works <emphasis>perfectly</emphasis> with your existent dependency management
                    infrastructure, be it Maven or Ivy. All the repositories you have set up with your custom POM or
                    ivy files can be used as they are. No changes necessary.
                </para>
                <para>Gradleでは、依存関係を管理するために構築された既存のインフラ、すなわちMavenやIvyのリポジトリを<emphasis>完全に</emphasis>サポートしています。独自にカスタムしたPOMや、ivyのメタデータを使ってセットアップされたリポジトリを、そのまま使うことができるのです。何一つ修正する必要はありません。</para>
            </listitem>
            <listitem>
                <para role="original">Additionally, Gradle offers a simpler approach, which might be better suited for some projects.
                </para>
                <para>さらに、Gradleはもっと単純な依存関係の解決方法も用意しています。プロジェクトによっては、そちらの管理方法の方が適しているかもしれません。</para>
            </listitem>
        </itemizedlist>
    </section>
    <section id='sec:dependency_management_overview'>
        <title>依存関係管理の概要<phrase role="original">Dependency management overview</phrase></title>
        <para role="original">We think dependency management is very important for almost any project. Yet the kind of dependency
            management you need depends on the complexity and the environment of your project. Is your project a
            distribution or a library? Is it part of an enterprise environment, where it is integrated into other
            projects builds or not? But all types of projects share the following requirements:
        </para>
        <para>依存関係の管理は、ほとんどすべてのプロジェクトにおいて非常に重要な要素になってくると思います。しかし、どんな方法で依存関係を管理するべきかはプロジェクトの複雑さや環境によって変わってきます。そのプロジェクトは配布物でしょうか。それともライブラリでしょうか。また、別プロジェクトと統合してビルドするような、エンタープライズ環境のプロジェクトの一部なのでしょうか、違うのでしょうか。ただ、どんな種類のプロジェクトにしろ以下に挙げた要件は満たしていなければなりません。</para>
        <itemizedlist>
            <listitem>
                <para role="original">The version of the jar must be easy to recognize. Sometimes the version is in the Manifest file of
                    the jar, often not. And even if, it is rather painful to always look into the Manifest file to learn
                    about the version. Therefore we think that you should only use jars which have their version as part
                    of their file name.
                </para>
                <para>依存しているjarのバージョンが簡単に分かるようになっていなければなりません。jarのバージョンはマニフェストファイルに書かれていたりいなかったりですが、バージョンを調べるためにわざわざマニフェストファイルを見ないといけないとなると面倒です。ファイル名にバージョンが付加されているjarだけを使うべきだと思います。</para>
            </listitem>
            <listitem>
                <para role="original">It hopes to be clear what are the first level dependencies and what are the transitive ones. There
                    are different ways to achieve this. We will look at this later.
                </para>
                <para>何が直接の依存関係で何が推移的な依存関係なのか、明確に分かるようになっていた方がいいでしょう。そのためにはいくつかの方法が考えられます。後ほど見ていきます。</para>
            </listitem>
            <listitem>
                <para role="original">Conflicting versions of the same jar should be detected and either resolved or cause an exception.
                </para>
                <para>同じjarに依存していて、バージョンが競合している場合は、それを検出して解決するか例外を発行しなければなりません。</para>
            </listitem>
        </itemizedlist>
        <section id='sub:versioning_the_jar_name'>
            <title>jarの名前にバージョンを付加する<phrase role="original">Versioning the jar name</phrase></title>
            <para role="original">Why do we think this is necessary? Without a dependency management as described above, your are likely
                to burn your fingers sooner or later. If it is unclear which version of a jar your are using, this can
                introduce subtle bugs which are very hard to find. For example there might be a project which uses
                Hibernate 3.0.4. There are some problems with Hibernate so a developer installs version 3.0.5 of
                Hibernate on her machine. This did not solve the problem but she forgot to roll back Hibernate to 3.0.4.
                Weeks later there is an exception on the integration machine which can't be reproduced on the developer
                machine. Without a version in the jar name this problem might take a long time to debug. Version in the
                jar names increases the expressiveness of your project and makes it easier to maintain.
            </para>
            <para>どうしてこんなことをする必要があるのか考えてみましょう。上記のような依存関係管理ができなければ、いつか悲惨なことになりかねません。使っているjarのバージョンがなんなのかよく分からないというのは、見つけづらい難解なバグへの第一歩です。たとえば、プロジェクトでHibernateの3.0.4を使っているとしましょう。Hibernateに関するところで何か問題が起こっているようなので、開発者は自分のマシンにHibernate3.0.5をインストールしました。しかし、これでは問題は解決しませんでした…ここで、彼女がHibernateを3.0.4に戻すのを忘れてしまった場合、どうなるでしょうか。数週間後、インテグレーションサーバーで例外が発生しました。開発者のマシンでは再現しません。jarファイル名にバージョンが含まれていなければ、このデバッグに長時間を費やしてしまう可能性があります。jarファイル名の中のバージョン文字列は、そのプロジェクトをわかりやすいものにし、メンテナンスも容易にしてくれるのです。</para>
        </section>
        <section id='sub:transitive_dependency_management'>
            <title>推移的な依存関係の管理<phrase role="original">Transitive dependency management</phrase></title>
            <para role="original">Why is transitive dependency management so important? If you don't know which dependencies are first
                level dependencies and which ones are transitive you will soon lose control over your build. Even
                Gradle has already 20+ jars. An enterprise project using Spring, Hibernate, etc. easily ends up with
                100+ jars. There is no way to memorize where all these jars come from. If you want to get rid of a first
                level dependency you can't be sure which other jars you should remove. Because a dependency of a
                first level dependency might also be a first level dependency itself. Or it might be a transitive
                dependency of another of your first level dependencies. Many first level dependencies are runtime
                dependencies and the transitive dependencies are of course all runtime dependencies. So the compiler
                won't help you much here. The end of the story is, as we have seen very often, no one dares to remove
                any jar any longer. The project classpath is a complete mess and if a classpath problem arises, hell on
                earth invites you for a ride. In one of my former projects, I found some ldap related jar in the
                classpath, whose sheer presence, as I found out after much research, accelerated LDAP access. So
                removing this jar would not have led to any errors at compile or runtime.
            </para>
            <para>推移的な依存関係が、なぜそんなに重要なのでしょうか。どの依存関係が直接依存しているもので、どの依存関係が推移的に依存しているのか分からなくなれば、ビルドシステムは早晩制御不能になるでしょう。Gradleでさえ20以上のjarから構成されています。SpringやHibernateなどのエンタープライズレベルのプロジェクトだと、jarの数はゆうに100を超えるでしょう。どのjarをどこからなぜ入れたのか、全部覚えておくようなことはできません。こうなると、なにか依存関係を破棄したいとなったとき、それに関連してどのjarを削除すればいいのか分からなくなります。削除しようとしているjarは、それ自身プロジェクトから直接使われているjarかもしれません。別の依存関係から推移的に依存されているかもしれません。プロジェクトが直接依存しているライブラリは、実行時のみの依存関係である場合も多いものです。もちろん、そこから推移する依存関係も実行時の依存関係になります。つまり、コンパイラは頼りにできないということです。このシナリオの行き着く先を、私たちはたくさん見てきました。もはや誰も、恐ろしくて何一つjarを削除できなくなってしまいます。プロジェクトのクラスパスは完全にめちゃくちゃになって、そのクラスパスで問題が発生しようものならこの世の地獄にご招待という話です。私が以前携わっていたプロジェクトでは、LDAPに関するjarをいくつかクラスパスに追加していました。後ほど調べて分かったのですが、このjarはあるだけでLDAPアクセスを高速化させます。つまり、このjarを取り除いたとしても、コンパイル時にも実行時にもエラーが発生することはなかったでしょう。</para>
            <para role="original">Gradle offers you different ways to express what are first level and what are transitive dependencies.
                Gradle allows you for example to store your jars in CVS or SVN without XML descriptor files and still
                use transitive dependency management. Gradle also validates your dependency hierarchy against the
                reality of your code by using only the first level dependencies for compiling.
            </para>
            <para>Gradleでは、何が直接依存していて何が推移的に依存しているのか、様々な方法で定義できます。たとえば、XMLのディスクリプタなしでjarをCVSやSVNに置いたとしても、推移的な依存関係は管理できます。さらに、依存関係の構造を検証し、コンパイルするコードが直接的な依存関係のみ使用しているかどうか、確認することもできます。</para>
        </section>
        <section id='sub:version_conflicts'>
            <title>バージョン競合<phrase role="original">Version conflicts</phrase></title>
            <para role="original">In your dependency description you tell Gradle which version of a dependency is needed by another
                dependency. This frequently leads to conflicts. Different dependencies rely on different versions of
                another dependency. The JVM unfortunately does not offer yet any easy way, to have different versions of
                the same jar in the classpath (see <xref linkend='sub:dependency_management_and_java'/>). What Gradle
                offers you is a resolution strategy, by default the newest version is used. To deal with problems due to
                version conflicts, reports with dependency graphs are also very helpful. Such reports are another
                feature of dependency management.
            </para>
            <para>依存関係の定義では、様々なライブラリが様々なバージョンのライブラリを要求します。これが依存関係の競合をよく引き起こすのです。つまり、同じライブラリの異なるバージョンが要求される場合があります。残念ながら、JVMではクラスパス上にバージョン違いの同じjarを混在させるのは、簡単なことではありません(<xref linkend='sub:dependency_management_and_java'/>参照)。Gradleは、どのようにバージョン競合を解決するかという戦略を提供します。デフォルトでは最新バージョンが使用されるようになっています。また、バージョン競合を解決する際には、依存関係をグラフにしたレポートを参照することが大きな助けになるでしょう。このようなレポートの生成が依存関係管理のもう一つの機能です。</para>
        </section>
        <section id='sub:dependency_management_and_java'>
            <title>依存関係の管理とJava<phrase role="original">Dependency management and Java</phrase></title>
            <para role="original">Traditionally, Java has offered no support at all for dealing with libraries and versions. There are
                no standard ways to say that
                <literal>foo-1.0.jar</literal>
                depends on a <literal>bar-2.0.jar</literal>. This has led to proprietary solutions. The most popular ones
                are Maven and Ivy. Maven is a complete build system whereas Ivy focuses solely on dependency management.
            </para>
            <para>Javaでは、伝統的に、ライブラリとバージョンの取り扱いをまったくサポートしてきませんでした。<literal>foo-1.0.jar</literal>が<literal>bar-2.0.jar</literal>に依存していると明確に宣言できるような、標準的な方法がないのです。そのため、様々なソリューションがプロプライエタリに開発されてきました。もっとも有名なものがMavenとIvyです。Ivyが依存関係の管理にのみフォーカスしているのに対し、Mavenはビルドシステム全体を取り扱います。</para>
            <para role="original">Both approaches rely on descriptor XML files, which contains information about the dependencies of a
                particular jar. Both also use repositories where the actual jars are placed together with their
                descriptor files. And both offer resolution for conflicting jar versions in one form or the other. Yet
                we think the differences of both approaches are significant
                in terms of flexibility and maintainability. Beside this, Ivy fully supports the Maven dependency
                handling. So with Ivy you have access to both worlds. We like Ivy very much. Gradle uses it under the
                hood for its dependency management. Ivy is most often used via Ant and XML descriptors. But it also has
                an API. We integrate deeply with Ivy via its API. This enables us to build new concepts on top
                of Ivy which Ivy does not offer itself.
            </para>
            <para>どちらも、jarの依存関係を記述したXMLのメタデータを使用します。そのメタデータと実際のjarファイルをリポジトリに保管する点も同じです。また、どちらも、jarファイルのバージョンが競合すれば、それを解決するための手段をなにかしら提供しています。IvyとMavenの違いは、私たちが考えるに、柔軟性やメンテナンス性です。加えて、IvyはMavenの管理する依存関係を完全にサポートしています。Ivyを使用すれば、IvyとMaven、両方の領域を取り扱うことができるのです。私たちはIvyが大好きで、Gradleも依存関係を管理するために内部でIvyを使用しています。Ivyは、一般的にはAntとXMLのメタデータから使用されますが、APIも用意されています。Gradleは、そのAPIを通してIvyを深いレベルで統合しているのです。このことで、Ivyそれ自体では提供していないような新しい概念を構築することができました。</para>
            <para role="original">Right now there is a lot of movement in the field of dependency handling. There is OSGi and there is
                JSR-294.
                <footnote>
                    <para role="original">JSR 294: Improved Modularity Support in the JavaTM Programming Language, <ulink url='http://jcp.org/en/jsr/detail?id=294'/>
                    </para>
                </footnote>
                OSGi is available already, JSR-294 is supposed to be shipped with Java 7. These technologies
                deal, amongst many other things, also with a painful problem which is neither solved by Maven nor by Ivy. This is enabling different
                versions of the same jar to be used at runtime.
            </para>
            <para>
            現在では、依存関係管理の分野には多くの活動があります。OSGiやJSR-294
            <footnote>
                <para>JSR 294: JavaTMプログラミング言語におけるモジュール化サポートの改善、<ulink url='http://jcp.org/en/jsr/detail?id=294'/>
            　　</para>
            </footnote>
            です。OSGiはすでに利用可能、JSR-294はJava7に盛り込まれるのではないかと言われています。これらのテクノロジーはさまざまな多くの問題を取り扱うもので、同じjarの異なるバージョンを実行時に有効化するという、MavenでもIvyでも解決できない困難な問題にも対応しています。
            </para>
        </section>
    </section>
    <section id='sec:how_to_declare_your_dependencies'>
        <title>依存関係の宣言方法<phrase role="original">How to declare your dependencies</phrase></title>
        <para role="original">People who know Ivy have come across most of the concepts we are going to introduce now. But Gradle does not
            use any XML for declaring the dependencies (e.g. no <literal>ivy.xml</literal> file). It has its own
            notation which is part of the Gradle build file.
        </para>
        <para>Ivyを知っている方にとっては、これから解説する概念のほとんどは既知のものかと思われます。ただし、Gradleは依存関係を宣言するのにXML(<literal>ivy.xml</literal>など)は一切使用しません。依存関係は、Gradleのビルドスクリプトに独自の記法で記述します。</para>
        <section id='sub:configurations'>
            <title>コンフィギュレーション<phrase role="original">Configurations</phrase></title>
            <para role="original">Dependencies are grouped in configurations. Configurations have a name, a number of other properties,
                and they can extend each other. For examples see: <xref linkend='sec:artifact_configurations'/>.
                If you use the Java plugin, Gradle adds a number of pre-defined configurations to your build. The
                plugin also assigns configurations to tasks. See <xref linkend='sec:java_plugin_and_dependency_management'/>
                for details. Of course you can add your add custom configurations on top of that. There are many use cases
                for custom configurations. This is very handy for example for adding dependencies not needed for
                building or testing your software (e.g. additional JDBC drivers to be shipped with your distribution).
                The configurations are managed by a <literal>configurations</literal> object. The closure you pass to
                the configurations object is applied against its API. To learn more about this API have a look at
                <apilink class='org.gradle.api.artifacts.ConfigurationContainer'/>.
            </para>
            <para>依存関係は、コンフィギュレーションによりグループ化されます。コンフィギュレーションは名前(name)といくつかのプロパティを持っていて、それらを別のコンフィギュレーションから継承することもできます(例:<xref linkend='sec:artifact_configurations'/>)。Javaプラグインを使用している場合、Gradleにより定義済みのコンフィギュレーションがいくつか追加されています。Javaプラグインは、さらにそれらのコンフィギュレーションをタスクに割り当てます。詳しくは<xref linkend='sec:java_plugin_and_dependency_management'/>をご参照ください。もちろん、定義済みのコンフィギュレーションに加えて、自分でカスタムのコンフィギュレーションを定義することもできます。カスタムのコンフィギュレーションには様々な使い道があります。たとえば、ビルド時にもテスト時にも使用されない依存関係(配布物に同梱するオプションのJDBCドライバなど)を追加するときなどに便利です。定義されているコンフィギュレーションは<literal>configurations</literal>オブジェクトで管理されています。このオブジェクトに渡したクロージャは、コンフィギュレーションのAPIに対して適用されます。このAPIについてさらに詳しく学ぶには、<apilink class='org.gradle.api.artifacts.ConfigurationContainer'/>をご参照ください。
</para>
        </section>
        <section id='sub:module_dependencies'>
            <title>モジュール依存関係<phrase role="original">Module dependencies</phrase></title>
            <para role="original">Module dependencies are the most common dependencies. They correspond to a dependency in an external
                repository.
            </para>
            <para>モジュール依存関係は、もっともポピュラーなタイプの依存関係です。外部リポジトリを使った依存関係に相当します。</para>
            <sample id="moduleDependencies" dir="userguide/artifacts/externalDependencies" title="モジュール依存関係 / Module dependencies">
                <sourcefile file="build.gradle" snippet="module-dependencies"/>
            </sample>
            <para role="original">Gradle provides different notations for module dependencies. There is a string notation and
                a map notation. A module dependency has an API which allows for further configuration. Have a look at
                <apilink class='org.gradle.api.artifacts.ExternalModuleDependency'/> to learn all about the API.
                This API provides properties and configuration methods. Via the string notation you can define a subset
                the properties. With the map notation you can define all properties. To have access to the complete API,
                either with the map or with the string notation, you can assign a single dependency to a configuration
                together with a closure.
            </para>
            <para>依存関係を定義する際、Gradleでは文字列記法とマップ記法を使用できます。モジュール依存関係はAPIを公開しているので、それを使用してさらに設定を行うこともできます。APIについての詳細は<apilink class='org.gradle.api.artifacts.ExternalModuleDependency'/>をご覧ください。このAPIではプロパティと設定用のメソッドを公開しており、文字列記法で設定できるのはプロパティのうちの一部です。マップ記法を使うとすべてのプロパティを設定できます。すべてのAPIにアクセスするには、文字列記法かマップ記法で依存関係をコンフィギュレーションに割り当てる際に、クロージャを使用してください。</para>
            <para role="original">If you declare a module dependency, Gradle looks for a corresponding module descriptor file (<literal>pom.xml</literal> or
                <literal>ivy.xml</literal>) in the repositories. If such a module descriptor file exists, it is parsed and the artifacts of
                this module (e.g. <literal>hibernate-3.0.5.jar</literal>) as well as its dependencies (e.g. cglib) are downloaded. If no such
                module descriptor file exists, Gradle looks for a file called <literal>hibernate-3.0.5.jar</literal> to retrieve. In Maven
                a module can only have one and only one artifact. In Gradle and Ivy a module can have multiple artifacts.
                Each artifact can have a different set of dependencies.
            </para>
            <para>モジュール依存関係を定義すると、Gradleはモジュールのメタデータファイル(<literal>pom.xml</literal>か<literal>ivy.xml</literal>)をリポジトリから探すようになります。モジュールのメタデータファイルがあれば解析して、モジュールのアーティファクト(たとえば<literal>hibernate-3.0.5.jar</literal>)とそのモジュールの依存関係(たとえばcglib)をダウンロードします。メタデータファイルがなければ、Gradleは依存関係を解決するため<literal>hibernate-3.0.5.jar</literal>という名前のファイルを探します。Mavenでは、一つのモジュールには一つのアーティファクトしかありません。GradleとIvyでは、モジュールは複数のアーティファクトを持つことができ、それぞれのアーティファクトがそれぞれの依存関係を持っています。</para>
            <section id='ssub:artifact_dependencies'>
                <title>アーティファクトオンリー記法<phrase role="original">Artifact only notation</phrase></title>
                <para role="original">As said above, if no module descriptor file can be found, Gradle by default
                    downloads a jar with the name of the module. But sometimes, even if the repository contains module descriptors,  you want to download only the artifact jar, without
                    the dependencies.
                    <footnote>
                        <para role="original">Gradle supports partial multiproject builds (see<xref linkend='multi_project_builds'/>).
                        </para>
                    </footnote>
                    And sometimes you want to download a zip from a repository, that does not have module descriptors.
                    Gradle provides an <emphasis>artifact only</emphasis> notation for those use cases - simply prefix the extension that you want to be downloaded with <literal>'@'</literal> sign:
                </para>
                <para>
                前述のように、もしモジュールのメタデータが見つからなければ、Gradleはデフォルトでモジュールの名前をjarの名前とみなして、そのjarファイルのみをダウンロードします。しかし場合によっては、たとえメタデータがあったとしても、アーティファクトのjarのみダウンロードして、モジュールの依存関係はダウンロードしたくないということもあります。
                    <footnote>
                        <para>Gradleはマルチプロジェクトの部分ビルドをサポートしています(<xref linkend='multi_project_builds'/>参照)。</para>
                    </footnote>
                    また、メタデータのないただのzipファイルをリポジトリからダウンロードしたい場合もあるでしょう。Gradleでは、このようなケースのためにアーティファクトオンリー記法が提供されています。ただ@とダウンロードしたい拡張子を指定するだけです。
                </para>
                <sample id="artifactOnly" dir="userguide/artifacts/externalDependencies" title="アーティファクトオンリー記法 / Artifact only notation">
                    <sourcefile file="build.gradle" snippet="artifact-only"/>
                </sample>
                <para role="original">
                    An artifact only notation creates a module dependency which downloads only the artifact file with
                    the specified extension. Existing module descriptors are ignored.
                </para>
                <para>
                    この記法を使うと、指定した拡張子をもつアーティファクトファイルのみダウンロードするというモジュール依存関係を作成できます。メタデータがあっても無視されます。
                </para>
            </section>
            <section id='ssub:classifiers'>
                <title>Classifiers</title>
                <para role="original">The Maven dependency management has the notion of classifiers.
                    <footnote>
                        <para role="original">
                            <ulink url='http://www.sonatype.com/books/maven-book/reference/pom-relationships-sect-project-relationships.html'/>
                        </para>
                    </footnote>
                    Gradle supports this. To retrieve classified dependencies from a maven repository you can write:
                </para>
                <para>
                Mavenには、classifiers(分類子)という記法があります。
                        <footnote>
                            <para>
                                <ulink url='http://www.sonatype.com/books/maven-book/reference/pom-relationships-sect-project-relationships.html'/>
                            </para>
                        </footnote>
                Gradleも分類子をサポートしています。Mavenリポジトリの分類された依存関係を解決するには、次のように記述します。
                </para>
                <sample id="classifier" dir="userguide/artifacts/excludesAndClassifiers" title="classifierつきの依存関係 / Dependency with classifier">
                        <sourcefile file="build.gradle" snippet="classifier"/>
                </sample>
                <para role="original">As you can see in the example, classifiers can be used together with setting
                an explicit extension (artifact only notation).</para>
                <para>例にあるように、分類子は明示的に拡張子を指定(アーティファクトオンリー記法)しても使うことができます。</para>
            </section>
        </section>
        <section id='sub:client_module_dependencies'>
            <title>クライアントモジュール依存関係<phrase role="original">Client module dependencies</phrase></title>
            <para role="original">Client module dependencies enable you to declare <emphasis>transitive</emphasis>
                dependencies directly in your build script. They are a replacement for a module descriptor XML file in
                an external repository.
            </para>
            <para>クライアントモジュール依存関係を使うと、<emphasis>推移的な</emphasis>依存関係をビルドスクリプトで直接定義できます。その定義は、外部リポジトリにあるXMLメタデータファイルの定義を上書きし、優先的に使用されます。</para>
            <sample id="client-modules" dir="userguide/artifacts/externalDependencies" title="クライアントモジュール依存関係 - 推移的な依存関係 / Client module dependencies - transitive dependencies">
                <sourcefile file="build.gradle" snippet="client-modules"/>
            </sample>
            <para role="original">This declares a dependency of your project on Groovy. Groovy itself has dependencies. But Gradle does
                not look for an XML descriptor to figure them out but gets the information from the build file. The
                dependencies of a client module can be normal module dependencies or artifact dependencies or another
                client module. Have also a look at the API documentation: <apilink class='org.gradle.api.artifacts.ClientModule'/>
            </para>
            <para>この例では、プロジェクトがGroovyに依存していることを定義しています。Groovyはそれ自身、依存関係を持っています。しかし、この例ではGradleはその依存関係をXMLメタデータファイルではなく、ビルドスクリプトから取得しているのです。</para>
            <para role="original">In the current release client modules have one limitation. Let's say your project is a library and
                you want this library to be uploaded to your company's Maven or Ivy repository. Gradle uploads the
                jars of your project to the company repository together with the XML descriptor file of the dependencies.
                If you use client modules the dependency declaration in the XML descriptor file is not correct. We will
                improve this in a future release of Gradle.
            </para>
            <para>現在、クライアントモジュール依存関係には一つ制限事項があります。プロジェクトがライブラリをビルドするもので、さらにそのライブラリを社内のMavenまたはIvyリポジトリにアップロードしたいと想定してください。Gradleはプロジェクトの成果物であるjarファイルをXMLのメタデータとともに社内リポジトリにアップロードします。クライアントモジュール依存関係を使っていた場合、このXMLのメタデータが正しいものにならないのです。将来のリリースでこれを改善する予定です。</para>
        </section>
        <section id='sub:project_dependencies'>
            <title>プロジェクト依存関係<phrase role="original">Project dependencies</phrase></title>
            <para role="original">Gradle distinguishes between external dependencies and dependencies on projects which are part of the
                same multi-project build. For the latter you can declare <firstterm>Project Dependencies</firstterm>.
            </para>
            <para>Gradleは、外部との依存関係の他、同じマルチプロジェクトビルドに属する複数のプロジェクト間の依存関係を取り扱います。後者を定義するためには、<firstterm>プロジェクト依存関係</firstterm>を使用します。</para>
            <sample id="project-dependencies" dir="java/multiproject/api" title="プロジェクト依存関係 / Project dependencies">
                <sourcefile file="build.gradle" snippet="project-dependencies"/>
            </sample>
            <para role="original">For more information see the API documentation for <apilink class="org.gradle.api.artifacts.ProjectDependency"/>
            </para>
            <para>詳しくはAPIドキュメントで<apilink class="org.gradle.api.artifacts.ProjectDependency"/>をご参照ください。</para>
            <para role="original">Multi-project builds are discussed in <xref linkend='multi_project_builds'/>.
            </para>
            <para>マルチプロジェクトビルドは<xref linkend='multi_project_builds'/>で詳細に論じられています。</para>
        </section>
        <section>
            <title>ファイル依存関係<phrase role="original">File dependencies</phrase></title>
            <para role="original">File dependencies allow you to directly add a set of files to a configuration, without first adding
                them to a repository. This can be useful if you cannot, or do not want to, place certain files in a
                repository. Or if you do not want to use any repositories at all for storing your dependencies.
            </para>
            <para>ファイル依存関係を使うと、ファイルセットをリポジトリに追加することなく直接コンフィギュレーションに設定できます。ファイルをリポジトリに登録できない、またはしたくないときに有用な依存関係です。また、プロジェクトの依存関係をどんなリポジトリにも記録したくないという場合にも使えます。</para>
            <para role="original">To add some files as a dependency for a configuration, you simply pass a
                <link linkend="sec:file_collections">file collection</link> as a dependency:</para>
            <para>ファイルを依存関係としてコンフィギュレーションに追加するには、単に<link linkend="sec:file_collections">file collection</link>を依存関係として渡すだけです。</para>
            <sample id="file-dependencies" dir="userguide/artifacts/externalDependencies" title="ファイル依存関係 / File dependencies">
                <sourcefile file="build.gradle" snippet="file-dependencies"/>
            </sample>
            <para role="original">File dependencies are not included in the published dependency descriptor for your project.
                However, file dependencies are included in transitive project dependencies within the same build.
                This means they cannot be used outside the current build, but they can be used with the same build.
            </para>
            <para>プロジェクトの依存関係を公開する際、ファイル依存関係は公開されるメタデータには含まれません。しかし、同じビルド内でプロジェクト依存関係を定義している場合、ファイル依存関係はプロジェクトの推移的な依存関係には含まれます。要するに、ファイル依存関係はそのビルドの外部からは使用されないが、内部では使用されるということです。</para>
            <para role="original">
                You can declare which tasks produce the files for a file dependency. You might do this when, for example,
                the files are generated by the build.
            </para>
            <para>ファイル依存関係では、どのタスクがそのファイルを作成するのか宣言することができます。これは、たとえばそのファイルがビルドによって生成される場合などに使うことがあります。</para>
            <sample id="generatedFileDependencies" dir="userguide/artifacts/generatedFileDependencies" title="生成されたファイルの依存関係 / Generated file dependencies">
                <sourcefile file="build.gradle" snippet="generated-file-dependencies"/>
                <output args="-q list"/>
            </sample>
        </section>
        <section>
            <title>Gradle API依存<phrase role="original">Gradle API Dependency</phrase></title>
            <para role="original">You can declare a dependency on the API of the current version of Gradle by using the
                <apilink class="org.gradle.api.artifacts.dsl.DependencyHandler" method="gradleApi"/> method. This is
                useful when you are developing custom Gradle tasks or plugins.</para>
            <para><apilink class="org.gradle.api.artifacts.dsl.DependencyHandler" method="gradleApi"/>メソッドを使って、使用しているバージョンのGradleAPIに依存していることを宣言できます。これは、カスタムのGradleタスクやプラグインを開発するときに便利です。</para>
            <sample id="gradle-api-dependencies" dir="java/multiproject/buildSrc" title="Gradle API依存 / Gradle API dependencies">
                <sourcefile file="build.gradle" snippet="gradle-api-dependencies"/>
            </sample>
        </section>
        <section id='sub:exclude_transitive_dependencies'>
            <title>推移的な依存関係の除外<phrase role="original">Excluding transitive dependencies</phrase></title>
            <para role="original">You can exclude a <emphasis>transitive</emphasis> dependency either by configuration or by dependency:
            </para>
            <para>コンフィギュレーションまたは依存関係の定義で、推移的な依存関係を除外することができます。</para>
            <sample id="exclude-dependencies" dir="userguide/artifacts/excludesAndClassifiers" title="推移的な依存関係の除外 / Excluding transitive dependencies">
                <sourcefile file="build.gradle" snippet="exclude-dependencies"/>
            </sample>
            <para role="original">If you define
                an exclude for a particular configuration, the excluded transitive dependency will be filtered for all
                dependencies when resolving this configuration or any inheriting configuration.
                If you want to exclude a transitive dependency from all your
                configurations you can use the Groovy spread-dot operator to express this in a concise way, as shown in the example.
                When defining an exclude, you can
                specify either only the organization or only the module name or both.
                Have also a look at the API documentation of <apilink class="org.gradle.api.artifacts.Dependency"/> and
                <apilink class="org.gradle.api.artifacts.Configuration"/>.
            </para>
            <para>コンフィギュレーションに対して除外設定した場合、そのコンフィギュレーション(とそれを継承したコンフィギュレーション)に属する依存関係すべてから、指定した推移的依存関係が取り除かれます。すべてのコンフィギュレーションから、ある依存関係を除外したい場合は、例にあるように、Groovyの展開演算子を使うことで簡単に実現できます。除外設定では、group名だけ、またはモジュール名だけで指定することもできますし、その両方で指定することもできます。APIドキュメントの<apilink class="org.gradle.api.artifacts.Dependency"/>と<apilink class="org.gradle.api.artifacts.Configuration"/>もご参照ください。</para>
        </section>
        <section>
            <title>オプショナル属性<phrase role="original">Optional attributes</phrase></title>
            <para role="original">All attributes for a dependency are optional, except the name. It depends on the repository type,
                which information is need for actually finding the dependencies in the repository.
                See <xref linkend='sec:repositories'/>. If you work for example with Maven repositories, you need to define the
                group, name and version. If you work with filesystem repositories you might only need the name or the name
                and the version.
            </para>
            <para id="para:dependencies_with_empty_attributes">依存関係を定義するとき設定する属性の中で、必須の属性はnameだけです。実際にリポジトリの依存関係を解決するときに、どの情報が必要になるかはリポジトリのタイプによって異なりますので、<xref linkend='sec:repositories'/>をご参照ください。たとえばMavenのリポジトリを使うのなら、group、name、versionは設定しなければなりません。しかしリポジトリにファイルシステムを使うのならnameのみ、またはnameとversionだけ設定すれば大丈夫でしょう。</para>
            <sample id="dependenciesWithEmptyAttributes" dir="userguide/artifacts/externalDependencies" title="依存関係のオプショナル属性 / Optional attributes of dependencies">
                <sourcefile file="build.gradle" snippet="dependencies-with-empty-attributes"/>
            </sample>
            <para role="original">You can also assign collections or arrays of dependency notations to a configuration:
            </para>
            <para id="para:notation_collections">依存関係定義のコレクションや配列をコンフィギュレーションに割り当てることもできます。</para>
            <sample id="listGrouping" dir="userguide/artifacts/externalDependencies" title="依存関係のコレクション、配列 / Collections and arrays of dependencies">
                <sourcefile file="build.gradle" snippet="list-grouping"/>
            </sample>
        </section>
        <section id="sec:dependency_configurations">
            <title>依存関係のコンフィギュレーション<phrase role="original">Dependency configurations</phrase></title>
            <para role="original">In Gradle a dependency can have different configurations (as your project can have different configurations). If you
            don't specify anything explicitly, Gradle uses the default configuration of the dependency. For dependencies
            from a Maven repository, the default configuration is the only available one anyway. If you work with Ivy repositories and
            want to declare a non-default configuration for your dependency you have to use the map notation and declare:
            </para>
            <para>Gradleでは、ひとつの依存関係が複数のコンフィギュレーションを持つことがあります(自分のプロジェクトで、複数のコンフィギュレーションを定義できるのと同じです)。コンフィギュレーションが明示的に指定されていない場合、Gradleはdefautコンフィギュレーションを使用します。Mavenリポジトリにある依存関係については、どのみちdefaultコンフィギュレーションしか使用できません。Ivyのリポジトリを使っていて、defaultコンフィギュレーション以外のコンフィギュレーションを使用したいときは、Map記法で次のように定義してください。</para>
            <sample id="dependencyConfigurations" dir="userguide/artifacts/externalDependencies" title="依存関係のコンフィギュレーション / Dependency configurations">
                <sourcefile file="build.gradle" snippet="dependency-configurations"/>
            </sample>
            <para role="original">To do the same for project dependencies you need to declare:</para>
            <para>プロジェクト依存についても同様です。</para>
            <sample id="dependencyConfigurationsProjects" dir="/java/multiproject/services/webservice"  title="プロジェクト依存関係のコンフィギュレーション / Dependency configurations for project">
                <sourcefile file="build.gradle" snippet="dependency-configurations"/>
            </sample>
        </section>
        <section>
            <title>依存関係のレポート<phrase role="original">Dependency reports</phrase></title>
            <para role="original">You can generate dependency reports from the command line (see <xref linkend="para:commandline_dependency_report"/>).
                With the help of the Project report plugin (see <xref linkend="project_reports_plugin"/>) such a report can be created by your build.
            </para>
            <para>コマンドラインから依存関係のレポートを生成できます(<xref linkend="para:commandline_dependency_report"/>参照)。また、プロジェクトレポートプラグイン(<xref linkend="project_reports_plugin"/>)を使えば、そのようなレポートを自分のビルドで生成させることもできます。</para>
        </section>
    </section>
    <section>
        <title>依存関係の使い方<phrase role="original">Working with dependencies</phrase></title>
        <para role="original">For the examples below we have the following dependencies setup:</para>
        <para>例として、次のような依存関係を定義します。</para>
        <sample id="configurationHandlingSetup" dir="userguide/artifacts/configurationHandling" title="Configuration.copy">
            <sourcefile file="build.gradle" snippet="setup"/>
        </sample>
        <para role="original">The dependencies have the following transitive dependencies:</para>
        <para>この依存関係は、以下の推移的な依存関係を持っています。</para>
        <para>shark-1.0 -> seal-2.0, tuna-1.0</para>
        <para>orca-1.0 -> seal-1.0</para>
        <para>tuna-1.0 -> herring-1.0</para>
        <para role="original">You can use the configuration to access the declared dependencies or a subset of those:
        </para>
        <para>コンフィギュレーションを使って、定義した依存関係や、そのサブセットにアクセスできます。</para>
        <sample id="configurationHandlingDependencies" dir="userguide/artifacts/configurationHandling" title="定義した依存関係へアクセスする / Accessing declared dependencies">
            <sourcefile file="build.gradle" snippet="dependencies"/>
            <output args="-q dependencies"/>
        </sample>
        <para role="original"><code>dependencies</code> returns only the dependencies belonging explicitly to the configuration.
            <code>allDependencies</code> includes the dependencies from extended
            configurations.
        </para>
        <para><code>dependencies</code>は、明示的にコンフィギュレーションに割り当てた依存関係のみ表示します。<code>allDependencies</code>は、それに加えて、継承元のコンフィギュレーションに属する依存関係も表示します。</para>
        <para role="original">To get the library files of the configuration dependencies you can do:
        </para>
        <para>コンフィギュレーションに属する依存関係に含まれるライブラリファイルを取得するには、次のようにします。</para>
        <sample id="configurationHandlingAllFiles" dir="userguide/artifacts/configurationHandling" title="Configuration.files">
            <sourcefile file="build.gradle" snippet="allFiles"/>
            <output args="-q allFiles"/>
        </sample>
        <para role="original">Sometimes you want the library files of a subset of the configuration dependencies (e.g. of a single dependency).
        </para>
        <para>コンフィギュレーションの依存関係から、あるサブセット(ひとつの依存関係のみなど)に含まれるライブラリのみを取り出したい場合もあるでしょう。</para>
        <sample id="configurationHandlingFiles" dir="userguide/artifacts/configurationHandling" title="Configuration.files with spec">
            <sourcefile file="build.gradle" snippet="files"/>
            <output args="-q files"/>
        </sample>
        <para role="original">The <code>Configuration.files</code> method always retrieves all artifacts of the <emphasis>whole</emphasis> configuration. It
        then filters the retrieved files by specified dependencies. As you can see in the example, transitive dependencies are included.
        </para>
        <para><code>Configuration.files</code>は、常にすべてのコンフィギュレーションに含まれるすべてのアーティファクトを取得します。ここでは、取得したファイルを依存関係名でフィルタして表示しました。この例の通り、推移的な依存関係も含まれています。</para>
        <para role="original">You can also copy a configuration. You can optionally specify that only a subset of dependencies from the orginal configuration
            should be copied. The copying methods come in two flavors. The <code>copy</code> method copies only the dependencies belonging
            explicitly to the configuration. The <code>copyRecursive</code> method copies all the dependencies, including the dependencies from extended
            configurations.
        </para>
        <para>コンフィギュレーションはコピーすることもできます。さらに、元のコンフィギュレーションから一部の依存関係のみコピーするといったこともできます。コピー用のメソッドは二つ用意されており、そのうちの一つ、<code>copy</code>メソッドは、明示的にコンフィギュレーションに所属させた依存関係のみコピーします。もう一つの<code>copyRecursive</code>メソッドは、継承元のコンフィギュレーションに属しているものも含めすべての依存関係をコピーするものです。</para>
        <sample id="configurationHandlingCopy" dir="userguide/artifacts/configurationHandling" title="Configuration.copy">
            <sourcefile file="build.gradle" snippet="copy"/>
             <output args="-q copy"/>
        </sample>
        <para role="original">It is important to note that the returned files of the copied configuration
            are often but not always the same than the returned files of the dependency subset of the original configuration.
            In case of version conflicts between
            dependencies of the subset and dependencies not belonging to the subset the resolve result might be different.</para>
        <para>注意するべきなのは、コピーされたコンフィギュレーションから返されるライブラリが、オリジナルのコンフィギュレーションのサブセットになるとは限らないという点です。「コピーされたサブセット」と、「コピーされなかった残りのサブセット」の間でバージョンの競合がある場合、依存関係の解決結果が異なることもあります。</para>
        <sample id="configurationHandlingCopyVsFiles" dir="userguide/artifacts/configurationHandling" title="Configuration.copy vs. Configuration.files">
            <sourcefile file="build.gradle" snippet="copyVsFiles"/>
             <output args="-q copyVsFiles"/>
        </sample>
        <para role="original">In the example above, <code>orca</code> has a dependency on <code>seal-1.0</code> whereas
            <code>shark</code> has a dependency on <code>seal-2.0</code>. The original configuration has therefore a version
            conflict which is resolved to the newer <code>seal-2.0</code> version. The <code>files</code> method therefore
            returns <code>seal-2.0</code> as a transitive dependency of <code>orca</code>. The copied configuration only has <code>orca</code>
            as a dependency and therefore there is no version conflict and <code>seal-1.0</code> is returned as a transitive
            dependency.
        </para>
        <para>上の例では、<code>orca</code>が<code>seal-1.0</code>に依存しており、<code>shark</code>は<code>seal-2.0</code>に依存しています。なので、オリジナルのコンフィギュレーションではバージョンの競合が発生しているわけです。そのため、この依存関係はより新しいバージョンである<code>seal-2.0</code>に解決され、推移的な依存関係として<code>seal-2.0</code>が表示されています。一方、コピー先のコンフィギュレーションには<code>orca</code>しか含まれていません。そのためバージョンの競合は発生しておらず、推移的な依存関係として<code>seal-1.0</code>が表示されているのです。</para>
        <para role="original">Once a configuration is resolved it is immutable. Changing its state or the state of one of its dependencies
            will cause an exception. You can always copy a resolved configuration. The copied configuration is in the unresolved
            state and can be freshly resolved.
        </para>
        <para>一度解決されたコンフィギュレーションは不変となります。その状態を変更したり、コンフィギュレーション内の依存関係の状態を変更したりすると例外が発生します。一方でコンフィギュレーションのコピーはいつでも可能です。コピーされたコンフィギュレーションは未解決状態であり、解決処理を新規に行うことができます。</para>
        <para role="original">To learn more about the API of the configuration class see the API documentation:
            <apilink class='org.gradle.api.artifacts.Configuration'/>.
        </para>
        <para>ConfigurationクラスのAPIをさらに詳しく知りたいときは、APIドキュメント(<apilink class='org.gradle.api.artifacts.Configuration'/>)をご参照ください。</para>
    </section>
    <section id='sec:repositories'>
        <title>リポジトリ<phrase role="original">Repositories</phrase></title>
        <para role="original">Gradle repository management, based on Apache Ivy, gives you a lot of freedom
            regarding repository layout and retrieval policies. Additionally Gradle provides various convenience
            method to add preconfigured repositories.
        </para>
        <para>Gradleのリポジトリ管理は、Apache Ivyをベースにしており、リポジトリのレイアウトや、リポジトリの場所を探す方法を柔軟に定義できるようになっています。加えて、Gradleは、定義済みのリポジトリ定義を簡単に追加するための便利なメソッドを色々提供しています。</para>
        <section id='sub:maven_repo'>
            <title>Mavenリポジトリ<phrase role="original">Maven repositories</phrase></title>
            <para role="original">To add the central Maven2 repository (<ulink url='http://repo1.maven.org/maven2'/>) simply
                type:
            </para>
            <para>Maven2のセントラルリポジトリ(<ulink url='http://repo1.maven.org/maven2'/>)は、ただ次のように書くだけで簡単に追加できます。</para>
            <sample id="mavenCentral" dir="userguide/artifacts/defineRepository" title="Mavenセントラルリポジトリを追加する / Adding central Maven repository">
                <sourcefile file="build.gradle" snippet="maven-central"/>
            </sample>
            <para role="original">Now Gradle will look for your dependencies in this repository.
            </para>
            <para>こうすることで、Gradleはこのリポジトリから依存関係を取得するようになります。</para>
            <para role="original">Quite often certain jars are not in the official Maven repository for licensing reasons (e.g. JTA),
                but its POMs are.
            </para>
            <para>あるjarが、POM上にはあるのに、ライセンス上の理由からMavenの公式リポジトリ上にないということは大変よくあることです(JTAとか)。</para>
            <sample id="mavenCentralJarRepo" dir="userguide/artifacts/defineRepository" title="Mavenリポジトリをいくつか追加する / Adding several Maven repositories">
                <sourcefile file="build.gradle" snippet="maven-central-jar-repo"/>
            </sample>
            <para role="original">Gradle will look first in the central Maven repository for the POM and the JAR. If the JAR can't be
                found there, it will look for it in the other repositories.
            </para>
            <para>Gradleは、まずMavenのセントラルリポジトリへPOMとJARを見に行きます。もしJARが見つからなければ、別のリポジトリを参照しに行きます。</para>
            <para role="original">For adding a custom Maven repository you can say:
            </para>
            <para>カスタムのMavenリポジトリを追加するには、次のようにします。</para>
            <sample id="mavenLikeRepo" dir="userguide/artifacts/defineRepository" title="カスタムMavenリポジトリを追加する / Adding custom Maven repository">
                <sourcefile file="build.gradle" snippet="maven-like-repo"/>
            </sample>
            <para role="original">To declare additional repositories to look for jars (like above in the example
                for the central Maven repository), you can say:
            </para>
            <para>次のようにすることで、jarを探しに行くリポジトリを、先ほどのMavenセントラルリポジトリの例のように、複数追加することが出来ます。</para>
            <sample id="mavenLikeRepoWithJarRepo" dir="userguide/artifacts/defineRepository" title="JARファイルのために、Mavenリポジトリを複数追加する / Adding additional Maven repositories for JAR files">
                <sourcefile file="build.gradle" snippet="maven-like-repo-with-jar-repo"/>
            </sample>
            <para role="original">The first URL is used to look for POMs and JARs. The subsequent URLs are used to look for JARs.
            </para>
            <para>最初のURLは、POMとJARを探すために使われます。それ以降のURLは、JARを探すために使われるものです。</para>
            <para role="original">To use the local Maven cache as a repository you can say:</para>
            <para>Mavenのローカルキャッシュをリポジトリとして使うには、次のようにします。</para>
            <sample id="mavenLocalRepo" dir="userguide/artifacts/defineRepository" title="Mavenのローカルキャッシュをリポジトリとして追加する / Adding the local Maven cache as a repository">
                <sourcefile file="build.gradle" snippet="maven-local"/>
            </sample>
            <section>
                <title>パスワードで保護されたMavenリポジトリへのアクセス<phrase role="original">Accessing password protected Maven repositories</phrase></title>
            	<para role="original">To access a password protected Maven repository (basic authentication) you need to use one of Ivy features:</para>
                <para>パスワードで保護(BASIC認証)されたMavenリポジトリへアクセスするには、Ivyの機能を使う必要があります。</para>
                <sample id="mavenPasswordProtectedRepo" dir="userguide/artifacts/defineRepository" title="パスワードで保護されたMavenリポジトリへのアクセス / Accessing password protected Maven repository">
	                <sourcefile file="build.gradle" snippet="maven-password-protected-repo"/>
        	    </sample>
        	    <para role="original">Host name should not include <literal>"http://"</literal> prefix. It is advisable to keep your login and password in <filename>gradle.properties</filename> rather than directly in the build file.</para>
                <para>ホスト名に「<literal>http://</literal>」を含めてはいけません。ログイン情報とパスワードは、ビルドファイルに直接書くよりは<filename>gradle.properties</filename>に書くのがお勧めです。</para>
            </section>
        </section>
        <section id='sec:flat_dir_resolver'>
            <title>フラットディレクトリ・リゾルバ<phrase role="original">Flat directory resolver</phrase></title>
            <para role="original">If you want to use a (flat) filesytem directory as a repository, simply type:
            </para>
            <para>ファイルシステム上の(フラットな)ディレクトリをリポジトリとして使用したい場合も、簡単に定義できます。</para>
            <sample id="flatDirMulti" dir="userguide/artifacts/defineRepository" title="フラットディレクトリ・リゾルバ / Flat repository resolver">
                <sourcefile file="build.gradle" snippet="flat-dir-multi"/>
            </sample>
            <para role="original">This adds repositories which look into one or more directories for finding dependencies. If you only
                work with flat directory resolvers you don't need to set all attributes of a dependency.
                See <xref linkend='para:dependencies_with_empty_attributes'/>
            </para>
            <para>これで、依存関係を取得するリポジトリとして、複数のディレクトリが追加されました。このフラットディレクトリ・リゾルバのみ使うのであれば、依存関係定義ですべての属性を定義する必要はありません。<xref linkend='para:dependencies_with_empty_attributes'/>をご参照ください。</para>
        </section>
        <section>
            <title>Ivy repositories</title>
            <para>To use an Ivy repository:</para>
            <sample id="ivyRepository" dir="userguide/artifacts/defineRepository" title="Ivy repository">
                <sourcefile file="build.gradle" snippet="ivy-repo"/>
            </sample>
            <para>See <apilink class="org.gradle.api.artifacts.dsl.IvyArtifactRepository"/> for details.</para>
            <section>
                <title>Accessing password protected Ivy repositories</title>
                <para>To access an Ivy repository which uses basic authentication, you specify the username and password to use when you define the repository:
                </para>
                <sample id="ivyRepository" dir="userguide/artifacts/defineRepository" title="Ivy repository">
                    <sourcefile file="build.gradle" snippet="authenticated-ivy-repo"/>
                </sample>
            </section>
        </section>
        <section>
            <title>More about preconfigured repositories</title>
            <para>The methods above for creating preconfigured repositories share some common behavior. For all of them, defining
                a name for the repository is optional. If no name is defined a default name is calculated, depending on the
                type of the repository. You might want to assign a name, if you want to access the declared repository. For example
                if you want to use it also for uploading your project artifacts. An explicit name might also be helpful when
                studying the debug output.
            </para>
            <para>これまで紹介してきた定義済みリポジトリの追加メソッドには、一つの共通した性質があります。オプションとしてリポジトリ名を定義できるのです。もしリポジトリ名が定義されていなければ、リポジトリの形式に依存したデフォルトの名前が生成されます。リポジトリ定義にアクセスしたい場合には、名前を割り当てたくなるかもしれません。たとえば、プロジェクトのアーティファクトをアップロードする場合などです。明示的に命名すると、デバッグ出力を調査するときに役に立つこともあります。</para>
            <para role="original">The values passed as arguments to the repository methods can be of any type, not just String. The value
                that is actually used, is the <code>toString</code> result of the argument object.
            </para>
            <para>リポジトリ定義メソッドに引き渡す値は、必ずしも文字列である必要はなく、どんな型のオブジェクトでも渡すことができます。実際には、引き渡されたオブジェクトを<code>toString</code>で変換した結果が使用されるのです。</para>
        </section>
        <section id='sub:cache'>
            <title>Cache</title>
            <para>When Gradle downloads artifacts from remote repositories it stores them in a local cache located at
                <literal>USER_HOME/.gradle/cache</literal>. When Gradle downloads artifacts from one of its
                predefined local resolvers (e.g. flat directory resolver), the cache is not used.
            </para>
            <para>リモートリポジトリからダウンロードされた依存関係は、<literal>USER_HOME/.gradle/cache</literal>にローカルキャッシュとして保存されます。一方、定義済みのローカルリゾルバ(フラットディレクトリ・リゾルバなど)から依存関係を取得した場合、ローカルキャッシュは依存ファイルの中間ストレージとしては使用されません。ただし、どちらの場合も、依存関係のディスクリプタは常にローカルキャッシュに保存されます。</para>
        </section>
        <section id='sub:more_about_ivy_resolvers'>
            <title>Ivyリゾルバについての補足<phrase role="original">More about Ivy resolvers</phrase></title>
            <para role="original">Gradle, thanks to Ivy under its hood, is extremely flexible regarding repositories:
            </para>
            Gradleは、水面下でIvyを使っているおかげで、とても柔軟にリポジトリを取り扱うことができます。たとえば、
            <itemizedlist>
                <listitem>
                    <para role="original">There are many options for the protocol to communicate with the repository (e.g. filesystem,
                        http, ssh, ...)
                    </para>
                    リポジトリと通信する方法(ファイルシステムから、httpで、またはsshを使って、etc...)がたくさん用意されている
                </listitem>
                <listitem>
                    <para role="original">Each repository can have its own layout.
                    </para>
                    <para>一つ一つのリポジトリが、それぞれ独自のレイアウトを持つことができる</para>
                </listitem>
            </itemizedlist>
            <para role="original">Let's say, you declare a dependency on the
                <literal>junit:junit:3.8.2</literal> library.
                Now how does Gradle find it in the repositories? Somehow the dependency information has to be mapped to a
                path. In contrast to Maven, where this path is fixed, with Gradle you can define a pattern that defines
                what the path will look like. Here are some examples:
                <footnote>
                    <para role="original">At
                        <ulink url='http://ant.apache.org/ivy/history/latest-milestone/concept.html'/>
                        you can learn more about ivy patterns.
                    </para>
                </footnote>
            </para>
            <para><literal>junit:junit:3.8.2</literal>へ依存していることを定義したとしましょう。このとき、Gradleはどのようにしてリポジトリからjunitを探すのでしょうか。そのためには、なんとかしてこの依存関係情報をファイルパスに変換する必要があります。Mavenではその変換方法は変更できませんが、Gradleではパスをどのように決定するか、そのパターンを自分で定義できます。たとえば、
                <footnote>
                    <para>ivyパターンについては<ulink url='http://ant.apache.org/ivy/history/latest-milestone/concept.html'/>で詳細な情報を知ることができます。</para>
                </footnote>
            </para>
            <para role="original"><![CDATA[
// Maven2 layout (if a repository is marked as Maven2 compatible, the organization (group) is split into subfolders according to the dots.)
someroot/[organisation]/[module]/[revision]/[module]-[revision].[ext]

// Typical layout for an ivy repository (the organization is not split into subfolder)
someroot/[organisation]/[module]/[revision]/[type]s/[artifact].[ext]

// Simple layout (the organization is not used, no nested folders.)
someroot/[artifact]-[revision].[ext]
]]></para>
            <programlisting><![CDATA[
// Maven2 レイアウト (Maven2と互換性があるとマークすれば、組織(グループ)フォルダは組織名のドットに従ってサブフォルダに分割される)
someroot/[organisation]/[module]/[revision]/[module]-[revision].[ext]

// 典型的なIvyリポジトリレイアウト(組織フォルダはサブフォルダに分割されない)
someroot/[organisation]/[module]/[revision]/[type]s/[artifact].[ext]

// シンプルなレイアウト(組織名は使用せず、フォルダをネストしない)
someroot/[artifact]-[revision].[ext]
]]></programlisting>
            <para role="original">To add any kind of repository (you can pretty easy write your own ones) you can do:
            </para>
            <para>どんな種類のリポジトリでも、簡単に定義できます。</para>
            <sample id="fileSystemResolver" dir="userguide/artifacts/excludesAndClassifiers" title="カスタムリポジトリの定義 / Definition of a custom repository">
                <sourcefile file="build.gradle" snippet="file-system-resolver"/>
            </sample>
            <para role="original">An overview of which Resolvers are offered by Ivy and thus also by Gradle can be found
                <ulink url='http://ant.apache.org/ivy/history/latest-milestone/settings/resolvers.html'>here</ulink>. With
                Gradle you just don't configure them via XML but directly via their API.
            </para>
            <para>Ivyで(つまりGradleで)どんなリゾルバを使えるか、概要を<ulink url='http://ant.apache.org/ivy/history/latest-milestone/settings/resolvers.html'>ここ</ulink>で見ることができます。Gradleを使えば、XMLを経由することなく、直接これらのAPIを操作できます。</para>
        </section>
    </section>
    <section id='sec:strategies_of_transitive_dependency_management'>
        <title>推移的依存関係を管理するための戦略<phrase role="original">Strategies for transitive dependency management</phrase></title>
        <para role="original">Many projects rely on the <ulink url='http://repo1.maven.org/maven2'>Maven2 repository</ulink>. This is not
            without problems.
        </para>
        <para>多くのプロジェクトが、<ulink url='http://repo1.maven.org/maven2'>Maven2リポジトリ</ulink>をあてにしています。これには問題がないわけではありません。</para>
        <itemizedlist>
            <listitem>
                <para role="original">The IBibilio repository can be down or has a very long response time.
                </para>
                <para>IBibilioリポジトリはダウンする可能性もあり、レスポンスが返るまで長い時間がかかります。</para>
            </listitem>
            <listitem>
                <para role="original">The <literal>pom.xml</literal>'s of many projects have wrong information (as one example, the POM of
                    <literal>commons-httpclient-3.0</literal> declares JUnit as a runtime dependency).
                </para>
                <para><literal>pom.xml</literal>に間違った情報を入れているプロジェクトがたくさんあります(たとえば、<literal>commons-httpclient-3.0</literal>はJUnitをruntime依存関係に設定している)。</para>
            </listitem>
            <listitem>
                <para role="original">For many projects there is not one right set of dependencies (as more or less imposed by the
                    <literal>pom</literal>
                    format).
                </para>
                「ただ一つの正当な依存関係」というものが決められないようなプロジェクトもたくさんあります。(つまり、<literal>pom</literal>の形式のせいで、押しつけられる依存関係が多すぎたり少なすぎたりすることがままあります。)
            </listitem>
        </itemizedlist>
        <para role="original">If your project relies on the IBibilio repository you are likely to need an additional custom repository,
            because:
        </para>
        <para>もしプロジェクトがIBibilioリポジトリに依存しているのであれば、カスタムリポジトリを追加することになるかもしれません。なぜなら、</para>
        <itemizedlist>
            <listitem>
                <para role="original">You might need dependencies that are not uploaded to IBibilio yet.
                </para>
                <para>まだIBibilioにアップロードされていない依存関係が必要になるかもしれません。</para>
            </listitem>
            <listitem>
                <para role="original">You want to deal properly with wrong metadata in a IBibilio <literal>pom.xml</literal>.
                </para>
                <para>IBibilioの<literal>pom.xml</literal>に誤ったメタデータが含まれているかもしれません。</para>
            </listitem>
            <listitem>
                <para role="original">You don't want to expose people who want to build your project, to the
                    downtimes or sometimes very long response times of IBibilio.
                </para>
                <para>IBibilioがダウンしたり調子が悪くなったりしたときでも、プロジェクトを正常にビルドできるようにしたいという場合もあります。</para>
            </listitem>
        </itemizedlist>
        <para role="original">It is not a big deal to set-up a custom repository.
            <footnote>
                <para role="original">If you want to shield your project from the downtimes of IBibilio things get more complicated. You
                    probably want to set-up a repository proxy for this. In an enterprise environment this is rather
                    common. For an open source project it looks like overkill.
                </para>
            </footnote>
            But it can be tedious, to keep it up to date. For a new version, you have always to create the new XML
            descriptor and the directories. And your custom repository is another infrastructure element which might
            have downtimes and needs to be updated. To enable historical builds, you need to keep all the past
            libraries and you need a backup. It is another layer of indirection. Another source of information
            you have to lookup. All this is not really a big deal but in its sum it has an impact. Repository Manager like
            Artifactory or Nexus make this easier. But for example open source projects don't usually have a host for those products.
        </para>
        <para>カスタムリポジトリのセットアップ自体はたいした作業ではありませんが
            <footnote>
                <para>
                    IBiblioのダウンからプロジェクトを防御したい場合は、もう少し複雑になります。おそらく、リポジトリのプロキシをセットアップすることになるでしょう。エンタープライズ環境では、むしろよくあるシチュエーションですが、オープンソースプロジェクトの場合は、やりすぎのように思えます。
                </para>
            </footnote>
            、そのリポジトリを最新に保つ作業は単調で退屈なものになりがちです。新しいバージョンが出るたびに、新しいXML設定ファイルとディレクトリを作成しなければなりません。それに、そのカスタムリポジトリもまたダウンしたり、保守する必要があったりするインフラのひとつです。過去のビルドを再現できるようにするには、過去使用したすべてのライブラリをバックアップしておく必要があります。だんだんと複雑さが増していくことになるのです。一つ一つは本当に大したことではないかもしれませんが、積み重なっていけばやはり問題です。こういった作業を簡単にしてくれるArtifactoryやNexusはリポジトリ管理者にとって嬉しい存在ですが、たとえばオープンソースプロジェクトなどがいつもこのような受け入れ先を用意できるわけではありません。</para>
        <para role="original">This is a reason why some projects prefer to store their libraries in their version control system. This
            approach is fully supported by Gradle. The libraries can be stored in a flat directory without any XML module
            descriptor files.  Yet Gradle offers complete transitive dependency management. You can use either client module
            dependencies to express the dependency relations, or artifact dependencies in case a first level dependency has no
            transitive dependencies. People can check out such a project from svn and have everything necessary to build it.
        </para>
        <para>いくつかのプロジェクトが、使用しているライブラリをバージョン管理システムに入れたがるのはこのあたりが理由です。この方法は、Gradleでは完全にサポートされています。ライブラリを、XML設定ファイルを一切使用せず、ただローカルディレクトリに入れておくことができるのです。また、その場合でも、Gradleは推移的な依存関係を完全に管理できます。クライアントモジュール依存関係を使って依存関係のグラフを表現したり、推移的な依存関係がない場合は、アーティファクトオンリー記法を使ったりできます。こうしたプロジェクトは、SVNからチェックアウトされた段階で、ビルドに必要なすべてのものがそろっていることになります。</para>
        <para role="original">If you are working with a distributed version control system like Git you probably don't want to
        use the version control system to store libraries as people check out the whole history. But even here the flexibility
        of Gradle can make your life easier. For example you can use a shared flat directory without XML descriptors and
        yet you can have full transitive dependency management as described above.</para>
    <para>Gitのような分散バージョン管理システムを使っている場合は、リポジトリにライブラリを格納したくないかもしれません。ユーザーがリポジトリの履歴をすべてチェックアウトする必要があるからです。しかし、たとえこのような場合でも、Gradleの柔軟性はあなたの生活をイージーにしてくれます。たとえば、XMLリポジトリなしの共有ディレクトリを使うこともできます。そして、この場合でも上記の方法で推移的な依存関係は完全に管理できるのです。</para>
        <para role="original">You could also have a mixed strategy. If your main concern is bad metadata in the <literal>pom.xml</literal> and maintaining
            custom XML descriptors,
            <emphasis>Client Modules</emphasis>
            offer an alternative. But you can of course still use Maven2 repo and your custom repository as a
            repository for
            <emphasis>jars only</emphasis>
            and still enjoy
            <emphasis>transitive</emphasis>
            dependency management. Or you can only provide client modules for POMs with bad metadata. For the
            jars and the correct POMs you still use the remote repository.
        </para>
        <para>これらを複合させた戦略をとることもあるでしょう。<literal>pom.xml</literal>の不良メタデータをなんとかしたい、カスタムPOMを使いたいということであれば、<emphasis>クライアントモジュール</emphasis>が一つの選択肢になります。しかし、そのときももちろんMaven2のリポジトリはそのまま使えますし、<emphasis>jarの取得だけ</emphasis>カスタムリポジトリを使い、<emphasis>推移的な</emphasis>依存関係の管理もそのままエンジョイできます。また、不良メタデータに代わるクライアントモジュールだけを用意することもできます。その場合、jarと正しいPOM情報の取得先については、今まで通りリモートリポジトリを使うということになります。</para>
        <section id='sub:implicit_transitive_dependencies'>
            <title>暗黙的な推移的依存関係<phrase role="original">Implicit transitive dependencies</phrase></title>
            <para role="original">There is another way to deal with transitive dependencies
                <emphasis>without</emphasis>
                XML descriptor files. You can do this with Gradle, but we don't recommend it. We mention it for the sake
                of completeness and comparison with other build tools.
            </para>
            <para>XML設定ファイル<emphasis>なし</emphasis>で推移的な依存関係を取り扱う方法がもう一つあります。Gradleで実現できる方法ではありますが、私たちはこの方法を推奨していません。他のビルドツールと比較する目的で解説します。</para>
            <para role="original">The trick is to use only artifact dependencies and group them in lists. That way you have somehow
                expressed, what are your first level dependencies and what are transitive dependencies (see
                <xref linkend="para:notation_collections"/>).
                But the draw-back is, that for the Gradle dependency management all dependencies are considered first level dependencies. The
                dependency reports don't show your real dependency graph and the
                <literal>compile</literal>
                task uses all dependencies, not just the first level dependencies. All in all, your build is less
                maintainable and reliable than it could be when using client modules. And you don't gain anything.
            </para>
            <para>そのトリックは、アーティファクトオンリー記法を使い、それらをリストでグループ化するというものです。この方法でも、なにが直接の依存関係で、何が推移的な依存関係なのか、なんとか表現することはできました(<xref linkend="para:notation_collections"/>を参照してください)。しかし、この方法の欠点は、Gradleの依存関係管理システムが、すべての依存関係を直接の依存関係として取り扱ってしまうことです。依存関係のレポートを出力させても正しい依存関係グラフは出てきませんし、<literal>compile</literal>タスクでも、直接的な依存関係だけでなく、すべての依存関係が使われてしまうことになります。クライアントモジュールを使った場合に比べると、大抵は保守性も信頼性も落ちてしまいますし、特にその分なにか利点があるわけでもありません。</para>
        </section>
    </section>
</chapter>
