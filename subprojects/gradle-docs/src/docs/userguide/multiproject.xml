<!--
  ~ Copyright 2009 the original author or authors.
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->
<chapter id='multi_project_builds' xmlns:xi="http://www.w3.org/2001/XInclude">
    <title>マルチプロジェクトのビルド / Multi-project Builds</title>
    <para>The powerful support for multi-project builds is one of Gradle's unique selling points. This topic is also the
        most intellectually challenging.
    </para>
    <para>マルチプロジェクトの強力なサポートは、Gradleのユニークなセールスポイントの一つです。また、マルチプロジェクト自体もっとも頭を使うやりがいのあるテーマでもあります。</para>
    <section id='sec:cross_project_configuration'>
        <title>プロジェクト間にまたがる共通設定 / Cross project configuration</title>
        <para>Let's start with a very simple multi-project build. After all Gradle is a general purpose build tool at
            its core, so the projects don't have to be java projects. Our first examples are about marine life.
        </para>
        まず、ごく簡単な例から始めましょう。なんと言ってもGradleは汎用のビルドツールですので、扱うプロジェクトがJavaプロジェクトである必要はありません。これから例として使用するプロジェクトは、海洋生物に関するものです。
        <section>
            <title>共通の振る舞いを定義する / Defining common behavior</title>
            <para>We have the following project tree. This is a multi-project build with a root project
                <literal>water</literal> and a subproject <literal>bluewhale</literal>.
            </para>
            <para>このプロジェクトは、以下のような木構造になっており。ルートプロジェクト「<literal>water</literal>」と、サブプロジェクトの「<literal>bluewhale</literal>(シロナガスクジラ)」からなるマルチプロジェクトです。</para>
            <sample id="multiprojectFirstExample" dir="userguide/multiproject/firstExample/water" includeLocation="true" title="マルチプロジェクト・ツリー - warter &amp; bluewhale projects / Multi-project tree - water &amp; bluewhale projects">
                <layout>
                    build.gradle
                    settings.gradle
                    bluewhale
                </layout>
                <sourcefile file="settings.gradle"/>
            </sample>
            <para>And where is the build script for the <literal>bluewhale</literal> project? In Gradle build scripts are optional.
                Obviously for a single project build, a project without a build script doesn't make much sense. For
                multiproject builds the situation is different. Let's look at the build script for the <literal>water</literal> project and
                execute it:
            </para>
            <para>で、<literal>bluewhale</literal>プロジェクトのビルドスクリプトは何処にあるのでしょう。Gradleでは、ビルドスクリプトは必須ではありません。シングルプロジェクトのビルドではビルドスクリプトのないプロジェクトなどたいした意味はありませんが、マルチプロジェクトの場合そうとは限りません。<literal>water</literal>のビルドスクリプトを見てみましょう。</para>
            <sample id="multiprojectFirstExample" dir="userguide/multiproject/firstExample/water" title="water(親プロジェクト)のビルドスクリプト / Build script of water (parent) project">
                <sourcefile file="build.gradle"/>
                <output args="-q hello"/>
            </sample>
            <para>Gradle allows you to access any project of the multi-project build from any build script. The Project
                API provides a method called <literal>project()</literal>, which takes a path as an argument and returns
                the Project object for this path. The capability to configure a project build from any build script we
                call <firstterm>cross project configuration</firstterm>. Gradle implements this via
                <firstterm>configuration injection</firstterm>.
            </para>
            <para>Gradleでは、どのビルドスクリプトからでも、マルチプロジェクトを構成するそれぞれのプロジェクトにアクセスすることができます。ビルドスクリプトでは<literal>project()</literal>というメソッドを使用でき、引数にプロジェクトへのパスを渡せばProjectオブジェクトを取得できます。つまり、あるプロジェクトを設定しようとしたとき、マルチプロジェクト内どのビルドスクリプトからでもプロジェクトを取得して設定できるのです。このことを、私たちは<firstterm>クロスプロジェクト設定</firstterm>と呼んでいます。Gradleは、この機能を<firstterm>設定の注入</firstterm>という技術を利用して実現しています。</para>
            <para>We are not that happy with the build script of the <literal>water</literal>  project. It is inconvenient to add the task
                explicitly for every project. We can do better. Let's first add another project called
                <literal>krill</literal> to our multi-project build.
            </para>
            <para><literal>water</literal>プロジェクトのビルドスクリプトには不満点があります。すべてのプロジェクトに手でこのタスクを追加していくのは面倒ですよね。もっといい書き方ができます。例では、<literal>krill(オキアミ)</literal>プロジェクトをマルチプロジェクトに追加してみます。</para>
            <sample id="multiprojectAddKrill" dir="userguide/multiproject/addKrill/water" includeLocation="true" title="マルチプロジェクトツリー - water, bluewhaleそしてkrill">
                <layout>
                    build.gradle
                    settings.gradle
                    bluewhale
                    krill
                </layout>
                <sourcefile file="settings.gradle"/>
            </sample>
            <para>Now we rewrite the <literal>water</literal> build script and boil it down to a single line.</para>
            <para><literal>water</literal>ビルドスクリプトを書き直し、一行で記述するようにします。</para>
            <sample id="multiprojectAddKrill" dir="userguide/multiproject/addKrill/water" title="Water project build script">
                <sourcefile file="build.gradle"/>
                <output args="-q hello"/>
            </sample>
            <para>Is this cool or is this cool? And how does this work? The Project API provides a property
                <literal>allprojects</literal>
                which returns a list with the current project and all its subprojects underneath it. If you call
                <literal>allprojects</literal>
                with a closure, the statements of the closure are delegated to the projects associated with <literal>
                    allprojects</literal>. You could also do an iteration via <literal>allprojects.each</literal>, but
                that would be more verbose.
            </para>
            <para>素晴らしい。これはどういう原理で動いているのでしょう。Project APIは<literal>allprojects</literal>というプロパティを提供しており、そのプロパティには現在のプロジェクトと、そのサブプロジェクトのリストが格納されています。 <literal>allprojects</literal>をクロージャとともに呼び出せば、クロージャの実行が<literal>allprojects</literal>に格納されたすべてのプロジェクトに委譲されます。もちろん<literal>allprojects</literal>をeachでループすることもできますが、記述が冗長になってしまいます。</para>
            <para>Other build systems use inheritance as the primary means for defining common behavior. We also offer
                inheritance for projects as you will see later. But Gradle uses configuration injection as the usual way
                of defining common behavior. We think it provides a very powerful and flexible way of configuring
                multiproject builds.
            </para>
            <para>他のビルドシステムでは、プロジェクト間の共通設定を行う方法として主に継承を使用します。後ほど紹介するように、Gradleでも同様にプロジェクト間の継承を使用することが出来ますが、Gradleではもっと使いやすい共通設定の定義方法としてこの設定の注入を使用します。設定の継承に比べて、設定を注入する方が柔軟性のある強力な方法だと考えているからです。</para>
        </section>
    </section>
    <section id='sec:subproject_configuration'>
        <title>サブプロジェクトの設定 / Subproject configuration</title>
        <para>The Project API also provides a property for accessing the subprojects only.
        </para>
        <para>Project APIはサブプロジェクトのみにアクセスする方法も提供します。</para>
        <section>
            <title>共通の振る舞いを定義する / Defining common behavior</title>
            <sample id="multiprojectUseSubprojects" dir="userguide/multiproject/useSubprojects/water" title="サブプロジェクト共通の振る舞いとすべてのプロジェクト共通の振る舞いをそれぞれ定義する / Defining common behaviour of all projects and subprojects">
                <sourcefile file="build.gradle"/>
                <output args="-q hello"/>
            </sample>
        </section>
        <section id='sub:adding_specific_behavior'>
            <title>個別の振る舞いを追加する / Adding specific behavior</title>
            <para>You can add specific behavior on top of the common behavior. Usually we put the project specific
                behavior in the build script of the project where we want to apply this specific behavior. But as we
                have already seen, we don't have to do it this way. We could add project specific behavior for the
                <literal>bluewhale</literal> project like this:
            </para>
            <para>共通の振る舞いの上に、それぞれのプロジェクト個別の振る舞いを追加することができます。普通は、プロジェクト個別の振る舞いはそのプロジェクトのビルドスクリプトに記述しますが、いままで見てきたようにかならずそうしなければいけないという訳ではありません。次の例に示すような方法で、サブプロジェクト<literal>bluewhale</literal>に個別の振る舞いを追加することもできます。</para>
            <sample id="multiprojectSubprojectsAddFromTop" dir="userguide/multiproject/subprojectsAddFromTop/water" title="プロジェクト個別の振る舞いを定義する / Defining specific behaviour for particular project">
                <sourcefile file="build.gradle"/>
                <output args="-q hello"/>
            </sample>
            <para>As we have said, we usually prefer to put project specific behavior into the build script of this
                project. Let's refactor and also add some project specific behavior to the <literal>krill</literal>
                project.
            </para>
            <para>前述のとおり、プロジェクト個別の振る舞いは、普通そのプロジェクトのビルドスクリプトに記述します。リファクタリングし、さらに<literal>krill</literal>プロジェクトにも振る舞いを追加してみましょう。</para>
            <sample id="multiprojectSpreadSpecifics" dir="userguide/multiproject/spreadSpecifics/water" includeLocation="true" title="krillプロジェクトに個別の振る舞いを定義する / Defining specific behaviour for project krill">
                <layout>
                    build.gradle
                    settings.gradle
                    bluewhale
                    bluewhale/build.gradle
                    krill
                    krill/build.gradle
                </layout>
                <sourcefile file="settings.gradle"/>
                <sourcefile file="bluewhale/build.gradle"/>
                <sourcefile file="krill/build.gradle"/>
                <sourcefile file="build.gradle"/>
                <output args="-q hello"/>
            </sample>
        </section>
        <section id='sub:project_filtering'>
            <title>プロジェクトのフィルタリング / Project filtering</title>
            <para>To show more of the power of configuration injection, let's add another project
                called <literal>tropicalFish</literal> and add more behavior to the build via the build script of the
                <literal>water</literal> project.
            </para>
            <para>設定の注入が持つもっと大きな力をお見せするために、<literal>tropicalFish(熱帯魚)</literal>プロジェクトを追加します。このプロジェクトに、<literal>water</literal>プロジェクトのビルドスクリプトから振る舞いを定義していきます。</para>
            <section id='ssub:filtering_by_name'>
                <title>名前によるフィルタリング / Filtering by name</title>
                <sample id="multiprojectAddTropical" dir="userguide/multiproject/addTropical/water" includeLocation="true" title="プロジェクトにカスタマイズした振る舞いを追加する(プロジェクト名によるフィルタリング) / Adding custom behaviour to some projects (filtered by project name)">
                    <layout>
                        build.gradle
                        settings.gradle
                        bluewhale
                        bluewhale/build.gradle
                        krill
                        krill/build.gradle
                        tropicalFish
                    </layout>
                    <sourcefile file="settings.gradle"/>
                    <sourcefile file="build.gradle"/>
                    <output args="-q hello"/>
                </sample>
                <para>The <literal>configure()</literal> method takes a list as an argument and applies the
                    configuration to the projects in this list.
                </para>
                <para>configure()は引数にリストを取るメソッドで、そのリストに格納されたプロジェクトに設定を適用します。</para>
            </section>
            <section id='ssub:filtering_by_properties'>
                <title>プロパティによるフィルタリング / Filtering by properties</title>
                <para>Using the project name for filtering is one option. Using dynamic project properties is another.
                </para>
                <para>フィルタリングに使用できるのはプロジェクト名だけではありません。プロジェクトの動的なプロパティもフィルタリングに使用できます。</para>
                <sample id="multiprojectTropicalWithProperties" dir="userguide/multiproject/tropicalWithProperties/water" includeLocation="true" title="プロジェクトにカスタマイズした振る舞いを追加する(プロパティによるフィルタリング)/ Adding custom behaviour to some projects (filtered by project properties)">
                    <layout>
                        build.gradle
                        settings.gradle
                        bluewhale
                        bluewhale/build.gradle
                        krill
                        krill/build.gradle
                        tropicalFish
                        tropicalFish/build.gradle
                    </layout>
                    <sourcefile file="settings.gradle"/>
                    <sourcefile file="bluewhale/build.gradle"/>
                    <sourcefile file="krill/build.gradle"/>
                    <sourcefile file="tropicalFish/build.gradle"/>
                    <sourcefile file="build.gradle"/>
                    <output args="-q hello"/>
                </sample>
                <para>In the build file of the <literal>water</literal> project we use an <literal>afterEvaluate</literal>
                    notification. This means that the closure we are passing gets evaluated <emphasis>after</emphasis>
                    the build scripts of the subproject are evaluated. As the property <literal>arctic</literal>
                    is set in those build scripts, we have to do it this way. You will find more on this topic in
                    <xref linkend='sec:dependencies_which_dependencies'/>
                </para>
                <para><literal>water</literal>プロジェクトのビルドスクリプトでは、<literal>afterEvaluate</literal>という宣言文が使用されています。<literal>afterEvaluate</literal>に引き渡されたクロージャは、そのプロジェクトのビルドスクリプトが評価された<emphasis>後に</emphasis>実行されます。サブプロジェクトの<literal>arctic</literal>プロパティは、それぞれのプロジェクトのビルドスクリプト内でセットされているので、この方法で<literal>arctic</literal>プロパティにアクセスする必要があるのです。このトピックは<xref linkend='sec:dependencies_which_dependencies'/>で詳しく解説されています。</para>
            </section>
        </section>
    </section>
    <section id='sec:execution_rules_for_multi_project_builds'>
        <title>マルチプロジェクトのビルド実行ルール / Execution rules for multi-project builds</title>
        <para>When we have executed the <literal>hello</literal> task from the root project dir things behaved in an
            intuitive way. All the <literal>hello</literal> tasks of the different projects were executed. Let's switch
            to the <literal>bluewhale</literal> dir and see what happens if we execute Gradle from there.
        </para>
        <para>helloタスクをルートプロジェクトのディレクトリで実行したとき、ビルドは直感に従う、自然な形で実行されました。つまり、サブプロジェクトに定義されたhelloタスクも含め、すべてのhelloタスクが実行されたのです。では、<literal>bluewhale</literal>ディレクトリでGradleを実行した場合、どのようにビルドが実行されるのでしょうか。</para>
        <sample id="multiprojectSubBuild" dir="userguide/multiproject/tropicalWithProperties/water/bluewhale" title="サブプロジェクトからビルドを実行する / Running build from subproject">
           <output args='-q hello'/>
        </sample>
        <para>The basic rule behind Gradle's behavior is simple. Gradle looks down the hierarchy, starting with the
            <emphasis>current dir</emphasis>, for tasks with the name
            <literal>hello</literal>
            an executes them. One thing is very important to note. Gradle
            <emphasis>always</emphasis>
            evaluates
            <emphasis>every</emphasis>
            project of the multi-project build and creates all existing task objects. Then, according to the task name
            arguments and the current dir, Gradle filters the tasks which should be executed. Because of Gradle's
            cross project configuration <emphasis>every</emphasis> project has to be evaluated before <emphasis>any</emphasis>
            task gets executed. We will have a closer look at this in the next section. Let's now have our last marine
            example. Let's add a task to <literal>bluewhale</literal> and <literal>krill</literal>.
        </para>
        <para>Gradleがビルドを実行するときの基本的なルールは単純なものです。この例では、Gradleは<literal>hello</literal>タスクを探して、カレントディレクトリからプロジェクト階層を降りていき、タスクを見つけるとそれを実行するだけです。ただし、非常に重要な注意点が一つあります。Gradleはマルチプロジェクトに参加している<emphasis>すべての</emphasis>プロジェクトを<emphasis>常に</emphasis>評価します。ビルドスクリプトに定義されているタスクオブジェクトは、すべて作成されるのです。そのあと、Gradleは実行時にコマンドに引き渡したタスク名と実行ディレクトリによって、実際に実行するタスクをフィルタリングします。Gradleのクロスプロジェクト設定を実現するため、すべてのプロジェクトはタスク実行前に評価されてなければなりません。次の節では、このことについてさらに詳しく見ていきます。さて、これまで作成してきた<literal>marine</literal>プロジェクトの<literal>bluewhale</literal>と<literal>krill</literal>に新しいタスクを追加しましょう。</para>
        <sample id="multiprojectPartialTasks" dir="userguide/multiproject/partialTasks/water" title="プロジェクトの評価と実行 / Evaluation and execution of projects">
            <sourcefile file="bluewhale/build.gradle"/>
            <sourcefile file="krill/build.gradle"/>
            <output args="-q distanceToIceberg"/>
        </sample>
        <para>Here the output without the <literal>-q</literal> option:</para>
        <para><literal>-q</literal>オプションを外すと、出力結果は以下のようになります。:</para>
        <sample id="multiprojectPartialTasksNotQuiet" dir="userguide/multiproject/partialTasks/water" title="プロジェクトの評価と実行 / Evaluation and execution of projects">
            <output args="distanceToIceberg"/>
        </sample>
        <para>The build is executed from the <literal>water</literal> project. Neither <literal>water</literal> nor
            <literal>tropicalFish</literal> have a task with the name <literal>distanceToIceberg</literal>. Gradle does
            not care. The simple rule mentioned already above is: Execute all tasks down the hierarchy which have this
            name. Only complain if there is <emphasis>no</emphasis> such task!
        </para>
        <para>ビルドは<literal>water</literal>プロジェクトのディレクトリで実行しています。<literal>water</literal>プロジェクトも<literal>tropicalFish</literal>プロジェクトもdistanceToIcebergという名前のタスクは持っていませんが、Gradleはそんなこと気にしません。前述の実行ルールに従って、プロジェクト階層にあるdistanceToIcebergという名前のタスクをすべて実行するだけです。distanceToIcebergタスクが一つもないときだけ警告を出してきます。</para>
    </section>
    <section id='sec:running_partial_build_from_the_root'>
        <title>絶対パスによるタスクの実行 / Running tasks by their absolute path</title>
        <para>As we have seen, you can run a multi-project build by entering any subproject dir and execute the build
            from there. All matching task names of the project hierarchy starting with the current dir are executed. But
            Gradle also offers to execute tasks by their absolute path (see also <xref linkend='sec:project_and_task_paths'/>):
        </para>
        <para>いままで見てきたように、マルチプロジェクトのビルドでは、任意のサブプロジェクトを、そのプロジェクトのディレクトリに移動して個別にビルドできます。その際、ビルド実行ディレクトリ以下の、指定したタスク名と一致するタスクはすべて実行されます。しかし、Gradleでは、タスクの絶対パスを指定することで、ディレクトリを移動せずとも特定のプロジェクトにあるタスクのみを実行することも可能です。</para>
        <sample id="multiprojectAbsoluteTaskPaths" dir="userguide/multiproject/tropicalWithProperties/water/tropicalFish" title="絶対パスによるタスクの実行 / Running tasks by their absolute path">
            <output args="-q :hello :krill:hello hello"/>
        </sample>
        <para>The build is executed from the <literal>tropicalFish</literal> project. We execute the <literal>hello</literal>
            tasks of the <literal>water</literal>, the <literal>krill</literal> and the <literal>tropicalFish</literal>
            project. The first two tasks are specified by there absolute path, the last task is executed on the name
            matching mechanism described above.
        </para>
        <para>ビルドは<literal>tropicalFish</literal>プロジェクトのディレクトリで実行されています。上記の例では、ルートプロジェクト<literal>watar</literal>、<literal>krill</literal>プロジェクト、そしてカレントのサブプロジェクト<literal>tropicalFish</literal>の<literal>hello</literal>がそれぞれ実行されます。</para>
    </section>
    <section id='sec:project_and_task_paths'>
        <title>プロジェクトとタスクのパス / Project and task paths</title>
        <para>A project path has the following pattern: It starts always with a colon, which denotes the root project.
            The root project is the only project in a path that is not specified by its name. The path
            <literal>:bluewhale</literal>
            corresponds to the file system path
            <literal>water/project</literal>
            in the case of the example above.
        </para>
        <para>プロジェクトのパスは、ルートプロジェクトを表すコロンで始まります。ルートプロジェクトはパス内では名前が指定されません。<literal>:bluewhale</literal>はファイルシステムで言えば「water/bluewhale」に対応します。</para>
        <para>The path of a task is simply its project path plus the task name. For example <literal>
            :bluewhale:hello</literal>. Within a project you can address a task of the same project just by its name.
            This is interpreted as a relative path.
        </para>
        <para>タスクのパスは、単純にプロジェクトパスにタスク名を加えるだけです(例 <literal>:bluewhale:hello</literal>)。なお、カレントのプロジェクトにあるタスクは、タスク名だけで指定できます。これは、絶対パスに対して、相対パスと考えることができます。</para>
        <para>Originally Gradle has used the
            <literal>'/'</literal>
            character as a natural path separator. With the introduction of directory tasks (see <xref
                    linkend='sec:directory_creation'/>) this was no longer possible, as the name of the directory task
            contains the
            <literal>'/'</literal>
            character.
        </para>
        <para>以前Gradleでは、プロジェクトのパスセパレータとして<literal>「/」</literal>を使用していました。しかし、このセパレータ文字は<literal>directory</literal>タスク(<xref linkend='sec:directory_creation'/>参照)が導入されたときに廃止されています。<literal>directory</literal>タスクのタスク名に、<literal>「/」</literal>が含まれるためです。</para>
    </section>
    <section id='sec:dependencies_which_dependencies'>
        <title>依存性 - なんの依存性？ / Dependencies - Which dependencies?</title>
        <para>The examples from the last section were special, as the projects had no <emphasis>Execution
            Dependencies</emphasis>. They had only <emphasis>Configuration Dependencies</emphasis>. Here is an example
            where this is different:
        </para>
        <para>先ほどまでの例は特殊なもので、プロジェクトの間で設定情報は依存関係がありましたが、実行に関しては依存関係がありませんでした。ここでは、実行の依存関係について見てきます。</para>
        <section id='sub:execution_time_dependencies'>
            <title>実行に関する依存関係 / Execution dependencies</title>
            <section id='ssub:dependencies_and_execution_order'>
                <title>依存関係と実行順序 / Dependencies and execution order</title>
                <sample id="multiprojectFirstMessages" dir="userguide/multiproject/dependencies/firstMessages/messages" includeLocation="true" title="依存関係とビルド実行順序 / Dependencies and execution order">
                    <layout>
                        settings.gradle
                        consumer
                        consumer/build.gradle
                        producer
                        producer/build.gradle
                    </layout>
                    <sourcefile file="settings.gradle"/>
                    <sourcefile file="consumer/build.gradle"/>
                    <sourcefile file="producer/build.gradle"/>
                    <output args="-q action"/>
                </sample>
                <para>This did not work out. If nothing else is defined, Gradle executes the task in alphanumeric order.
                    Therefore
                    <literal>:consumer:action</literal>
                    is executed before <literal>:producer:action</literal>. Let's try to solve this with a hack and
                    rename the producer project to <literal>aProducer</literal>.
                </para>
                <para>この例はうまく動作しません。依存関係が定義されていないと、Gradleはタスクをアルファベット順に実行します。したがって、<literal>:consumer(消費者):action</literal>が<literal>:producer(供給者):action</literal>より先に実行されてしまうのです。<literal>producer</literal>プロジェクトの名前を<literal>aProducer</literal>に修正すればこの問題を解決することはできます。</para>
                <sample id="multiprojectMessagesHack" dir="userguide/multiproject/dependencies/messagesHack/messages" title="依存関係とビルド実行順序 / Dependencies and execution order">
                    <layout>
                        settings.gradle
                        aProducer
                        aProducer/build.gradle
                        consumer
                        consumer/build.gradle
                    </layout>
                    <sourcefile file="settings.gradle"/>
                    <sourcefile file="aProducer/build.gradle"/>
                    <sourcefile file="consumer/build.gradle"/>
                    <output args="-q action"/>
                </sample>
                <para>Now we take the air out of this hack. We simply switch to the <literal>consumer</literal> dir and
                    execute the build.
                </para>
                <para>ただ、このハックは簡単に破綻してしまいます。consumerディレクトリに移動して、ビルドしてみましょう。</para>
                <sample id="multiprojectMessagesHackBroken" dir="userguide/multiproject/dependencies/messagesHack/messages/consumer" title="依存関係とビルド実行順序 / Dependencies and execution order">
                    <output args="-q action"/>
                </sample>
                <para>For Gradle the two
                    <literal>action</literal>
                    tasks are just not related. If you execute the build from the
                    <literal>messages</literal>
                    project Gradle executes them both because they have the same name and they are down the hierarchy.
                    In the last example only one
                    <literal>action</literal>
                    was down the hierarchy and therefore it was the only task that got executed. We need something
                    better than this hack.
                </para>
                <para>結局、Gradleにとってこの二つのタスクはなんの関係もない別個のタスクにすぎません。<literal>messages</literal>プロジェクトをビルドすれば、Gradleはこの二つのタスクを両方とも実行しますが、それは二つのタスクが同じ名前のタスクであり、両方とも実行ディレクトリ以下にあるからです。最後の例では一方のタスクが実行ディレクトリから外れたので、片方のタスクしか実行されませんでした。依存関係を定義するには、それに適した方法が必要になります。</para>
            </section>
            <section id='ssub:declaring_dependencies'>
                <title>依存関係を宣言する / Declaring dependencies</title>
                <sample id="multiprojectMessagesDependencies" dir="userguide/multiproject/dependencies/messagesWithDependencies/messages" includeLocation="true" title="依存関係を宣言する">
                    <layout>
                        settings.gradle
                        consumer
                        consumer/build.gradle
                        producer
                        producer/build.gradle
                    </layout>
                    <sourcefile file="settings.gradle"/>
                    <sourcefile file="consumer/build.gradle"/>
                    <sourcefile file="producer/build.gradle"/>
                    <output args="-q action"/>
                </sample>
                <para>Running this from the <literal>consumer</literal> directory gives:</para>
                <para><literal>consumer</literal>ディレクトリでビルドすると、以下のようになります。</para>
                <sample id="multiprojectMessagesDependenciesSubBuild" dir="userguide/multiproject/dependencies/messagesWithDependencies/messages/consumer" title="依存関係を宣言する">
                    <output args="-q action"/>
                </sample>
                <para>We have now declared that the
                    <literal>consumer</literal>
                    project has an
                    <emphasis>execution dependency</emphasis>
                    on the
                    <literal>producer</literal>
                    project. For Gradle declaring
                    <emphasis>execution dependencies</emphasis>
                    between
                    <emphasis>projects</emphasis>
                    is syntactic sugar. Under the hood Gradle creates task dependencies out of them. You can also create
                    cross project tasks dependencies manually by using the absolute path of the tasks.
                </para>
                <para><literal>consumer</literal>プロジェクトは<literal>producer</literal>プロジェクトの実行に依存することを宣言しました。プロジェクト間の実行依存の宣言はGradleの構文糖衣で、実際にはタスク間の実行依存を作成しています。タスクの絶対パスを使って、プロジェクト間にまたがるタスクの実行依存関係を手で定義することもできます。</para>
            </section>
            <section id='ssub:the_nature_of_project_dependencies'>
                <title>プロジェクト間依存関係の性質 / The nature of project dependencies</title>
                <para>Let's change the naming of our tasks and execute the build.
                </para>
                <para>タスクの名前を変えてビルドしてみましょう。</para>
                <sample id="multiprojectMessagesDifferentTaskNames" dir="userguide/multiproject/dependencies/messagesDifferentTaskNames/messages" title="プロジェクト間の実行依存 / Project execution dependencies">
                    <sourcefile file="consumer/build.gradle"/>
                    <sourcefile file="producer/build.gradle"/>
                    <output args="-q consume"/>
                </sample>
                <para>Oops. Why does this not work? The
                    <literal>dependsOn</literal>
                    command is created for projects with a common lifecycle. Provided you have two Java projects where
                    one depends on the other. If you trigger a compile for the dependent project you don't want that
                    <emphasis>all</emphasis>
                    tasks of the other project get executed. Therefore a
                    <literal>dependsOn</literal>
                    creates dependencies between tasks with equal names. To deal with the scenario above you would do
                    the following:
                </para>
                <para>おっと、失敗してしまいました…なんででしょうか？ プロジェクトに対する<literal>dependsOn</literal>コマンドは、同じライフサイクルをもつプロジェクトの間で使用されることを前提にしています。二つのJavaプロジェクトがあるとして、一つのプロジェクトの<literal>compile</literal>タスクを実行したときに、依存先プロジェクトにあるすべてのタスクを実行されたくはないでしょう。なので、プロジェクトに対する<literal>dependsOn</literal>は同じ名前のタスク間でのみ依存関係を作成するのです。この例に挙げたシナリオでは、次のように依存関係を宣言する必要があるでしょう。</para>
                <sample id="multiprojectMessagesTaskDependencies" dir="userguide/multiproject/dependencies/messagesTaskDependencies/messages" title="プロジェクトにまたがるタスク間の依存関係 / Cross project task dependencies">
                    <sourcefile file="consumer/build.gradle"/>
                    <sourcefile file="producer/build.gradle"/>
                    <output args="-q consume"/>
                </sample>
            </section>
        </section>
        <section id='sub:configuration_time_dependencies'>
            <title>設定時の依存関係 / Configuration time dependencies</title>
            <para>Let's have one more example with our producer-consumer build before we enter
                <emphasis>Java</emphasis>
                land. We add a property to the producer project and create now a configuration time dependency from
                consumer on producer.
            </para>
            <para>そろそろ実際の<emphasis>Java</emphasis>での例をみていきたいと思いますが、その前に、producer-consumerプロジェクトについてもう一つ例を見てみます。ひとつのプロパティをproducerプロジェクトに加えて、consumerプロジェクトから設定時の依存関係をproducerプロジェクトに作成します。</para>
            <sample id="multiprojectMessagesConfigDependenciesBroken" dir="userguide/multiproject/dependencies/messagesConfigDependenciesBroken/messages" title="設定時の依存関係 / Configuration time dependencies">
                <sourcefile file="consumer/build.gradle"/>
                <sourcefile file="producer/build.gradle"/>
                <output args="-q consume"/>
            </sample>
            <para>The default
                <emphasis>evaluation</emphasis>
                order of the projects is alphanumeric (for the same nesting level). Therefore the
                <literal>consumer</literal>
                project is evaluated before the
                <literal>producer</literal>
                project and the
                <literal>key</literal>
                value of the
                <literal>producer</literal>
                is set
                <emphasis>after</emphasis>
                it is read by the
                <literal>consumer</literal>
                project. Gradle offers a solution for this.
            </para>
            <para>デフォルトでは、プロジェクトはプロジェクト名のアルファベット順で評価されます。したがって、<literal>consumer</literal>プロジェクトは<literal>producer</literal>プロジェクトの前に評価され、<literal>producer</literal>プロジェクトのプロパティは<literal>consumer</literal>プロジェクトが読みにいった後にセットされてしまうのです。Gradleでは、このような問題に対する解決策を提供しています。</para>
            <sample id="multiprojectMessagesConfigDependencies" dir="userguide/multiproject/dependencies/messagesConfigDependencies/messages" title="設定時の依存関係 - evaluationDependsOn / Configuration time dependencies - evaluationDependsOn">
                <sourcefile file="consumer/build.gradle"/>
                <output args="-q consume"/>
            </sample>
            <para>The command
                <literal>evaluationDependsOn</literal>
                triggers the evaluation of
                <literal>producer</literal>
                <emphasis>before</emphasis>
                <literal>consumer</literal>
                is evaluated. The example is a bit contrived for the sake of showing the mechanism. In
                <emphasis>this</emphasis>
                case there would be an easier solution by reading the key property at execution time.
            </para>
            <para>この<literal>evaluationDependsOn</literal>コマンドにより、<literal>producer</literal>プロジェクトが<literal>consumer</literal>の前に評価されるようになります。なお、この例はメカニズムを説明するためのやや不自然なものです。この場合は実行時にタスク内でプロパティを読みにいった方が早いでしょう。</para>
            <sample id="multiprojectMessagesConfigDependenciesAltSolution" dir="userguide/multiproject/dependencies/messagesConfigDependenciesAltSolution/messages" title="設定時の依存関係 / Configuration time dependencies">
                <sourcefile file="consumer/build.gradle"/>
                <output args="-q consume"/>
            </sample>
            <para>Configuration dependencies are very different to execution dependencies. Configuration dependencies
                are between projects whereas execution dependencies are always resolved to task dependencies. Another
                difference is that always all projects are configured, even when you start the build from a subproject.
                The default configuration order is top down, which is usually what is needed.
            </para>
            <para>設定時の依存関係は、実行時の依存関係と大きく異なる点がいくつかあります。まず、実行の依存関係が常にタスク間の依存関係になるのに対し、設定の依存関係はプロジェクト間の依存関係です。さらに、サブプロジェクトをビルドしたとしても、常にマルチプロジェクトのプロジェクトすべてが評価されるという違いもあります。デフォルトでは、ルートプロジェクトからトップダウンでサブプロジェクトに向かって評価されていきます。普通はその順序で評価する必要があるからです。</para>
            <para>On the same nesting level the configuration order depends on the alphanumeric position. The most
                common use case is to have multi-project builds that share a common lifecycle (e.g. all projects use the
                Java plugin). If you declare with
                <literal>dependsOn</literal>
                a
                <emphasis>execution dependency</emphasis>
                between different projects, the default behavior of this method is to create also a
                <emphasis>configuration</emphasis>
                dependency between the two projects. Therefore it is likely that you don't have to define configuration
                dependencies explicitly.
            </para>
            <para>同じ階層にあるプロジェクトは、プロジェクト名のアルファベット順で評価されます。よく使われるのは、同じビルドサイクルを共有するプロジェクトでマルチプロジェクトを構成するときです(すべてのプロジェクトがJavaプラグインを使うなど)。プロジェクト間に実行の依存関係を定義すると、設定の依存関係も同様に定義されます。したがって、設定の依存関係を明示的に指定することはあまりないかもしれません。</para>
        </section>
        <section id='sub:real_life_examples'>
            <title>実生活での例 / Real life examples</title>
            <para>Gradle's multi-project features are driven by real life use cases. The first example for describing
                such a use case, consists of two webapplication projects and a parent project that creates a
                distribution out of them.
                <footnote>
                    <para>The real use case we had, was using <ulink url='http://lucene.apache.org/solr'/>, where you
                        need a separate war for each index your are accessing. That was one reason why we have created a
                        distribution of webapps. The Resin servlet container allows us, to let such a distribution point
                        to a base installation of the servlet container.
                    </para>
                    <para>実際のケースでは<ulink url='http://lucene.apache.org/solr'/>を使っており、warファイルをアクセスするインデックスごとに分割する必要がありました。分散型のウェブアプリケーションを作成したひとつの理由はそれです。サーブレットコンテナResinはそのような分散させたWebアプリケーションを、ベースとなるサーブレットコンテナをポイントするよう設定することができます。</para>
                </footnote>
                For the example we use only one build script and do <emphasis>cross project configuration</emphasis>.
            </para>
            <para>Gradleのマルチプロジェクト機能は、開発現場でのユースケースに基づいて作成されています。ここではそのようなユースケースの例として、二つのWebアプリケーションとそれらの配布物を作成する親プロジェクトを紹介します。この例では、<emphasis>クロスプロジェクト設定</emphasis>を使って、一つのビルドスクリプトでそれぞれのプロジェクトの設定を行っています。</para>
            <sample id="webdist" dir="userguide/multiproject/dependencies/webDist" includeLocation="true" title="依存性 - 実生活の例 - クロスプロジェクト設定 / Dependencies - real life example - crossproject configuration">
                <layout>
                    settings.gradle
                    build.gradle
                    date
                    date/src/main/java/org/gradle/sample/DateServlet.java
                    hello
                    hello/src/main/java/org/gradle/sample/HelloServlet.java
                </layout>
                <sourcefile file="settings.gradle"/>
                <sourcefile file="build.gradle"/>
            </sample>
            <para>We have an interesting set of dependencies. Obviously the
                <literal>date</literal>
                and
                <literal>hello</literal>
                task have a
                <emphasis>configuration</emphasis>
                dependency on <literal>webDist</literal>, as all the build logic for the webapp projects is injected by
                <literal>webDist</literal>. The
                <emphasis>execution</emphasis>
                dependency is in the other direction, as
                <literal>webDist</literal>
                depends on the build artifacts of
                <literal>date</literal>
                and <literal>hello</literal>. There is even a third dependency.
                <literal>webDist</literal>
                has a
                <emphasis>configuration</emphasis>
                dependency on
                <literal>date</literal>
                and
                <literal>hello</literal>
                because it needs to know the <literal>archivePath</literal>. But it asks for this information at
                <emphasis>execution time</emphasis>. Therefore we have no circular dependency.
            </para>
            依存性について興味を持っています。明らかに<literal>date</literal>プロジェクトと<literal>hello</literal>プロジェクトのタスクは<literal>webDist</literal>に対して設定時に依存しています。すべてのwebappのためのビルドロジックはwebDistによって注入されているからです。しかし、実行時の依存性はそれとは逆です。webDistはhelloとdateの成果物を使ってビルドするからです。さらに、三つ目の依存関係もあります。wbeDistは、設定時依存をdateとhelloに対して持っています。なぜなら、タスクのarchivePathプロパティの値を知っておく必要があるからです。しかし、この問い合わせは実行時に行われます。なので、循環依存にはなっていないのです。
            <para>Such and other dependency patterns are daily bread in the problem space of multi-project builds. If a
                build system does not support such patterns, you either can't solve your problem or you need to do ugly
                hacks which are hard to maintain and massively afflict your productivity as a build master.
            </para>
            この手の依存性パターンはマルチプロジェクトのビルドではよく発生する問題です。ビルドシステムがこのような問題に対応できなければ、自らのビルドで発生する問題は解決できないか、もしくは見苦しいハックを行うハメになってメンテナンスが難しくなり、ビルドの管理者として生産性を大きく落としてしまうことになるでしょう。
            <para>There is one more thing to note from the current example. We have used the command <literal>
                dependsOnChildren()</literal>. It is a convenience method and calls the
                <literal>dependsOn</literal>
                method of the parent project for every child project (not every sub project). It declares a
                <literal>execution</literal>
                dependency of
                <literal>webDist</literal>
                on
                <literal>date</literal>
                and <literal>hello</literal>.
            </para>
            <para>この例には、注目すべき点がもう一つあります。私たちはdependsOnChildren()というコマンドを使っています。これは親プロジェクトがすべての子プロジェクト(すべてのサブプロジェクトではありません)に対してdependsOnを呼び出す便利なメソッドです。webDistがdateとhelloに実行時の依存関係を持っていることを宣言しているのです。</para>
            <para>Another use case would be a situation where the subprojects have a configuration
                <emphasis>and</emphasis>
                execution dependency on the parent project. This is the case when the parent project does configuration
                injection into its subprojects, and additionally produces something at execution time that is needed by
                its child projects (e.g. code generation). In this case the parent project would call the
                <literal>childrenDependOnMe</literal>
                method to create an execution dependency for the child projects. We might add an example for this in a
                future version of the user guide.
            </para>
            そのほかのユースケースとしては、サブプロジェクトが設定依存と実行依存を親プロジェクトに対して持っている場合が考えられます。このケースでは、親プロジェクトは設定の注入をそれぞれのプロジェクトに対して行い、さらに子プロジェクトが必要とする何かを実行時に作成するわけです(たとえば、コード生成など)。
        </section>
    </section>
    <section id='sec:project_jar_dependencies'>
        <title>Project lib dependencies</title>
        <para>What if one projects needs the jar produced by another project in its compile path? And not just the jar
            but also the transitive dependencies of this jar? Obviously this is a very common use case for Java
            multi-project builds. As already mentioned in <xref linkend='sub:project_dependencies'/>, Gradle
            offers project lib dependencies for this.
        </para>
        <sample id="javadependencies_1" dir="userguide/multiproject/dependencies/java" includeLocation="true" title="Project lib dependencies">
            <layout>
                settings.gradle
                build.gradle
                api
                api/src/main/java/org/gradle/sample/api/Person.java
                api/src/main/java/org/gradle/sample/apiImpl/PersonImpl.java
                services
                services/personService
                services/personService/src/main/java/org/gradle/sample/services/PersonService.java
                services/personService/src/test/java/org/gradle/sample/services/PersonServiceTest.java
                shared
                shared/src/main/java/org/gradle/sample/shared/Helper.java
            </layout>
        </sample>
        <para>We have the projects <literal>shared</literal>,
            <literal>api</literal>
            and <literal>personService</literal>.
            <literal>personService</literal>
            has a lib dependency on the other two projects.
            <literal>api</literal>
            has a lib dependency on <literal>shared</literal>.
            <footnote>
                <para>
                    <literal>services</literal>
                    is also a project, but we use it just as a container. It has no build script and gets nothing
                    injected by another build script.
                </para>
            </footnote>
        </para>
        <sample id="javadependencies_2" dir="userguide/multiproject/dependencies/java" title="Project lib dependencies">
            <sourcefile file="settings.gradle"/>
            <sourcefile file="build.gradle"/>
        </sample>
        <para>All the build logic is in the
            <literal>build.gradle</literal> of the root project.
            <footnote>
                <para>We do this here, as it makes the layout a bit easier. We usually put the project specific stuff
                    into the buildscript of the respective projects.
                </para>
            </footnote>
            A <emphasis>lib</emphasis>
            dependency is a special form of an execution dependency. It causes the other project to be build first and
            adds the jar with the classes of the other project to the classpath. It also add the dependencies of the
            other project to the classpath. So you can enter the
            <literal>api</literal>
            directory and trigger a <userinput>gradle compile</userinput>. First
            <literal>shared</literal>
            is built and then
            <literal>api</literal>
            is built. Project dependencies enable partial multi-project builds.
        </para>
        <para>If you come from Maven land you might be perfectly happy with this. If you come from Ivy land, you might
            expect some more fine grained control. Gradle offers this to you:
        </para>
        <sample id="javaWithCustomConf" dir="userguide/multiproject/dependencies/javaWithCustomConf" title="Fine grained control over dependencies">
            <sourcefile file="build.gradle"/>
        </sample>
        <para>The Java plugin adds per default a jar to your project libraries which contains all the classes. In this
            example we create an
            <emphasis>additional</emphasis>
            library containing only the interfaces of the
            <literal>api</literal>
            project. We assign this library to a new <emphasis>dependency configuration</emphasis>. For the person
            service we declare that the project should be compiled only against the
            <literal>api</literal>
            interfaces but tested with all classes from <literal>api</literal>.
        </para>
        <section id="disable_dependency_projects">
            <title>Disable the build of dependency projects.</title>
            <para>Sometimes you don't want depended on projects to be built when doing a partial build.
                To disable the build of the depended on projects you can run gradle with the <code>-a</code> option.
            </para>
        </section>
    </section>
    <section id="sec:multiproject_build_and_test">
        <title>Multi-Project Building and Testing</title>
        <para>The <literal>build</literal> task of the Java plugin is typically used to compile, test, and perform
            code style checks (if the CodeQuality plugin is used) of a single project.  In multi-project builds
            you may often want to do all of these tasks across a range of projects.  The <literal>buildNeeded</literal>
            and <literal>buildDependents</literal> tasks can help with this.
        </para>
        <para>Let's use the project structure shown in <xref linkend='javadependencies_2'/>.  In this
            example :services:personservice depends on both :api and :shared.  The :api project also depends on
            :shared.
        </para>
        <para>Assume you are working on a single project, the :api project.  You have been making changes, but
            have not built the entire project since performing a clean.  You want to build any necessary supporting
            jars, but only perform code quality and unit tests on the project you have changed.
            The <literal>build</literal> task does this.
        </para>
        <sample id="multitestingBuild" dir="userguide/multiproject/dependencies/java" title="Build and Test Single Project">
            <output args=":api:build"/>
        </sample>

        <para>While you are working in a typical development cycle repeatedly building and testing changes to a
            the :api project (knowing that you are only changing files in this one project), you may not want to
            even suffer the expense of :shared:compile checking to see what has changed in the :shared project.
            Adding the <literal>-a</literal> option will cause gradle to use cached jars to resolve any project lib
            dependencies and not try to re-build the depended on projects.
        </para>
        <sample id="multitestingBuildDashA" dir="userguide/multiproject/dependencies/java" title="Partial Build and Test Single Project">
            <test args=":shared:assemble"/>
            <output args="-a :api:build"/>
        </sample>

        <para>If you have just gotten the latest version of source from your version control system which included changes
            in other projects that :api depends on, you might want to not only build all the projects you depend on,
            but test them as well. The <literal>buildNeeded</literal> task also tests all the projects from the
            project lib dependencies of the testRuntime configuration.
        </para>
        <sample id="multitestingBuildNeeded" dir="userguide/multiproject/dependencies/java" title="Build and Test Depended On Projects">
            <output args=":api:buildNeeded"/>
        </sample>

        <para>You also might want to refactor some part of the :api project that is used in other projects.
            If you make these types of changes, it is not sufficient to test just the :api,
            project, you also need to test all projects that depend on the :api project.
            The <literal>buildDependents</literal> task also tests all the projects that have a project lib dependency
            (in the testRuntime configuration) on the specified project.
        </para>
        <sample id="multitestingBuildDependents" dir="userguide/multiproject/dependencies/java" title="Build and Test Dependent Projects">
            <output args=":api:buildDependents"/>
        </sample>
        <para>Finally, you may want to build and test everything in all projects.  If the root project has declared
        <literal>dependsOnChildren()</literal> (as this one does), then any task you run against the root project
        will cause that same named task to be run on all the children.  So you can just run
        <literal>gradle build</literal> to build and test all projects.
        </para>
    </section>
    <section id='sec:property_and_method_inheritance'>
        <title>Property and method inheritance</title>
        <para>Properties and methods declared in a project are inherited to all its subprojects. This is an alternative
            to configuration injection. But we think that the model of inheritance does not reflect the problem space of
            multi-project builds very well. In a future edition of this user guide we might write more about this.
        </para>
        <para>Method inheritance might be interesting to use as Gradle's
            <emphasis>Configuration Injection</emphasis>
            does not support methods yet (but will in a future release.).
        </para>
        <para>You might be wondering why we have implemented a feature we obviously don't like that much. One reason is
            that it is offered by other tools and we want to have the check mark in a feature comparison :). And we like
            to offer our users a choice.
        </para>
    </section>
    <section>
        <title>Summary</title>
        <para>Writing this chapter was pretty exhausting and reading it might have a similar effect. Our final message
            for this chapter is that multi-project builds with Gradle are usually
            <emphasis>not</emphasis>
            difficult. There are six elements you need to remember: <literal>allproject</literal>, <literal>
            subprojects</literal>, <literal>dependsOn</literal>, <literal>childrenDependOnMe</literal>,
            <literal>dependsOnChildren</literal>
            and project lib dependencies.
            <footnote>
                <para>So we are well in the range of the
                    <ulink url='http://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two'>7 plus 2
                        Rule
                    </ulink>
                    :)
                </para>
            </footnote>
            With those elements, and keeping in mind that Gradle has a distinct configuration and execution phase, you
            have already a lot of flexibility. But when you enter steep territory Gradle does not become an obstacle and
            usually accompanies and carries you to the top of the mountain.
        </para>
    </section>
</chapter>
